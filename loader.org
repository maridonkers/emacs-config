#+TITLE: Emacs configuration using org-mode
#+STARTUP: indent
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing

* Introduction
GNU Emacs org-mode configuration file. Based on Arjen Wiersma's
[[https://gitlab.com/buildfunthings/emacs-config][emacs-config]], Sacha Chua's [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs configuration]], Daniel Mai's [[https://github.com/danielmai/.emacs.d][Mai
Emacs Configuration]] and [[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org][Uncle Dave's Emacs]]. Plus various snippets from the internet.

You can find the latest version of this configuration at
[[https://github.com/maridonkers/emacs-config]].

Disclaimer: tested only (my configuration) on Linux, with emacs 25.1.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Mari Donkers")

(defvar user-emacs-cache-directory
  (concat (getenv "HOME") "/.cache/emacs"))
#+END_SRC
* Installing use-package
** Setup
GNU Emacs has a lot of packages that make things very easy for the
user. The package management infrastructure makes it a breeze to
install new packages and keep up-to-date with their development.

There are several package archives available for GNU Emacs:

- GNU
- Marmalade
- Melpa

Each archive will write its files in a seperate archive directory.

#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar gnu '("gnu" . "http://elpa.gnu.org/packages/"))
(defvar melpa '("melpa" . "http://melpa.org/packages/"))
(defvar melpa-stable '("melpa-stable" . "http://stable.melpa.org/packages/"))

;; Add repositories (resetting defaults first).
(setq package-archives nil)
(add-to-list 'package-archives melpa-stable t)
(add-to-list 'package-archives melpa t)
(add-to-list 'package-archives gnu t)
#+END_SRC

Initialize the archive and refresh the contents in case there is no cached archive.

#+BEGIN_SRC emacs-lisp
  ;; (package-initialize)

  (unless (and (file-exists-p (concat init-dir "elpa/archives/gnu"))
               (file-exists-p (concat init-dir "elpa/archives/melpa"))
               (file-exists-p (concat init-dir "elpa/archives/melpa-stable")))
          (package-refresh-contents))
#+END_SRC

At each load the package list will be evaluated and any missing
packages will be installed. The packages-install function deals with
this check and takes care of any loading of the packages.

#+BEGIN_SRC emacs-lisp
(defun packages-install (&rest packages)
  (message "running packages-install")
    (mapc (lambda (package)
            (let ((name (car package))
                  (repo (cdr package)))
              (when (not (package-installed-p name))
                (let ((package-archives (list repo)))
                  (package-initialize)
                  (package-install name)))))
          packages)
    (package-initialize)
    (delete-other-windows))
#+END_SRC
** The package
#+BEGIN_SRC emacs-lisp
;; Install extensions if they're missing
(defun init--install-packages ()
  (message "Lets install some packages")
  (packages-install
   ;; Since use-package this is the only entry here
   ;; ALWAYS try to use use-package!
   (cons 'use-package melpa)))

(condition-case nil
  (init--install-packages)
  (error (package-refresh-contents)
         (init--install-packages)))
#+END_SRC
** Additionals for use-package
Because use-package supports :diminish and :delight.
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t)
(use-package delight
  :ensure t)
#+END_SRC
* Emacs
** Initialization
- Turn off mouse interface early in startup to avoid momentary display.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
** Configuration
*** TODO gc-cons-threshold
To solve lsp-mode slowness after e.g. find definition. Is it necessary with eglot?
#+BEGIN_SRC emacs-lisp
;;(setq gc-cons-threshold (eval-when-compile (* 1024 1024 1024)))
;;(run-with-idle-timer 2 t (lambda () (garbage-collect)))
#+END_SRC
*** Visit quickly
#+BEGIN_SRC emacs-lisp
(defun config-visit ()
  "Visits ~/.emacs.d/loader.org"
  (interactive)
  (find-file "~/.emacs.d/loader.org"))
(global-set-key (kbd "s-c v") 'config-visit)
#+END_SRC
*** Reload
#+BEGIN_SRC emacs-lisp
(defun config-reload ()
  "Reloads ~/.emacs.d/loader.org at runtime"
  (interactive)
  (org-babel-load-file (expand-file-name "~/.emacs.d/loader.org")))
(global-set-key (kbd "s-c r") 'config-reload)
#+END_SRC
*** Delete frame
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x <C-backspace>") 'delete-frame)
#+END_SRC
*** Lockfiles
Don't want them.
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC
** Menu bar switch
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c h") 'menu-bar-mode)
#+END_SRC
** Cursor
*** TODO Set cursor color explicitly
(?) TODO: investigate why this is required
(the cursor doesn't have the correct color otherwise, for
emacsclient).
#+BEGIN_SRC emacs-lisp
(require 'frame)
(defun set-cursor-hook (frame)
  (modify-frame-parameters frame
                           (list (cons 'cursor-color "#ffff00"))))

(add-hook 'after-make-frame-functions 'set-cursor-hook)
#+END_SRC
*** Multiple cursors
The package [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]].
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :diminish multiple-cursors-mode
  :config (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
          (global-set-key (kbd "C-S-SPC") 'mc/edit-lines)
          (global-set-key (kbd "C->") 'mc/mark-next-like-this)
          (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
          (global-set-key (kbd "C-M-S-SPC") 'mc/mark-all-like-this))
#+END_SRC
*** Beacon
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :diminish beacon-mode
  :config
    (beacon-mode 1))
#+END_SRC
** TODO Prerequisite packages
  #+BEGIN_SRC emacs-lisp
    ;; (require 'cl)
  #+END_SRC
** Look and feel
*** Theme
#+BEGIN_SRC emacs-lisp
(use-package cyberpunk-theme
  :ensure t)

(load-theme 'cyberpunk t)

;; To accomodate aging eyes.
(set-face-attribute 'default nil :height 135)

;; Selection color.
;;(set-face-background 'hl-line "#3e4446")
;; (set-face-foreground 'highlight nil)

;; Font size
(define-key global-map (kbd "C-c C-=") 'text-scale-increase)
(define-key global-map (kbd "C-c C--") 'text-scale-decrease)

;; Clearer active window bar.
(set-face-attribute  'mode-line-inactive
                    nil
                    :foreground "white"
                    :background "#232323"
                    ;; :box '(:line-width 1 :style released-button)
                    :box nil)

(set-face-attribute  'mode-line
                    nil
                    :foreground "black"
                    :background "darkcyan"
                    ;; :box '(:line-width 1 :style released-button)
                    :box nil)

;; No boxes around mode line (cyberpunk theme creates these).
(set-face-attribute `mode-line nil :box nil)
(set-face-attribute `mode-line-inactive nil :box nil)

;; Set cursor color, shape and no blinking.
(setq-default cursor-color "#ffff00")
(set-cursor-color "#ffff00")
;;(setq-default cursor-type 'hollow)
(blink-cursor-mode 0)
#+END_SRC
*** Sane defaults
[[https://github.com/danielmai/.emacs.d/blob/master/config.org]].
#+BEGIN_SRC emacs-lisp
;; These functions are useful. Activate them.
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)

;; Answering just 'y' or 'n' will do
(defalias 'yes-or-no-p 'y-or-n-p)

;; UTF-8 please
(setq locale-coding-system 'utf-8) ; pretty
(set-terminal-coding-system 'utf-8) ; pretty
(set-keyboard-coding-system 'utf-8) ; pretty
(set-selection-coding-system 'utf-8) ; please
(prefer-coding-system 'utf-8) ; with sugar on top
(setq-default indent-tabs-mode nil)

(setq-default indent-tabs-mode nil)
(setq-default indicate-empty-lines t)

;; Don't count two spaces after a period as the end of a sentence.
;; Just one space is needed.
(setq sentence-end-double-space nil)

;; delete the region when typing, just like as we expect nowadays.
(delete-selection-mode t)

(show-paren-mode t)

(column-number-mode t)

(global-visual-line-mode)
;TODO CHECK ERROR: symbol's function definition is void: diminish
;(diminish 'visual-line-mode)

(setq uniquify-buffer-name-style 'forward)

;; Turn off emacs alarms (those annoying beeps)
(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
*** Title
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      (list (format "%s %%S: %%j " (system-name))
        '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))
#+END_SRC
*** Desktop
Also check this out: [[https://emacs.stackexchange.com/questions/31621/handle-stale-desktop-lock-files-after-emacs-system-crash][Handle stale desktop lock files after emacs/system crash]]
#+BEGIN_SRC emacs-lisp
;; Store desktop (i.e. open files, etc.) at exit (restores when starting again).
(setq desktop-path '("."))
(desktop-save-mode 1)
#+END_SRC
*** Ignore error wrapping
#+BEGIN_SRC emacs-lisp
;(defun ignore-error-wrapper (fn)
;  "Funtion return new function that ignore errors.
;   The function wraps a function with `ignore-errors' macro."
;  (lexical-let ((fn fn))
;    (lambda ()
;      (interactive)
;      (ignore-errors
;        (funcall fn)))))
#+END_SRC
*** Moving around
**** Bookmarks
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x r <return>") 'bookmark-save)
#+END_SRC
**** Bookmarks (bm)
Bookmarks are very useful for quickly jumping around files.
#+BEGIN_SRC emacs-lisp
(use-package bm
  :ensure t
  :bind (("<M-S-return>" . bm-toggle)
         ("<M-S-up>" . bm-previous)
         ("<M-S-down>" . bm-next)))
#+END_SRC
*** Winner mode
#+BEGIN_SRC emacs-lisp
;; Winner mode
;; From: http://www.emacswiki.org/emacs/WinnerMode
(when (fboundp 'winner-mode)
  (winner-mode 1))
#+END_SRC
*** Window swapping
From [[https://www.emacswiki.org/emacs/TransposeWindows][Transpose Windows]].
#+BEGIN_SRC emacs-lisp
;; Initialization of these variables is required.
(setq swapping-buffer nil)
(setq swapping-window nil)

;; First call marks window and after switch to second window call
;; again to swap the windows.
(defun swap-buffers-in-windows ()
   "Swap buffers between two windows"
   (interactive)
   (if (and swapping-window
            swapping-buffer)
       (let ((this-buffer (current-buffer))
             (this-window (selected-window)))
         (if (and (window-live-p swapping-window)
                  (buffer-live-p swapping-buffer))
             (progn (switch-to-buffer swapping-buffer)
                    (select-window swapping-window)
                    (switch-to-buffer this-buffer)
                    (select-window this-window)
                    (message "Swapped buffers."))
           (message "Old buffer/window killed.  Aborting."))
         (setq swapping-buffer nil)
         (setq swapping-window nil))
     (progn
       (setq swapping-buffer (current-buffer))
       (setq swapping-window (selected-window))
       (message "Buffer and window marked for swapping."))))

;; Switch windows.
;;(global-set-key (kbd "C-c C-w") 'transpose-windows)
(global-set-key (kbd "C-c C-w") 'swap-buffers-in-windows)

(global-set-key [f9] 'other-window)
#+END_SRC
*** Window moving
#+BEGIN_SRC emacs-lisp
  ;; Windmove configuration.
;  (global-set-key (kbd "C-c <C-left>") (ignore-error-wrapper 'windmove-left))
;  (global-set-key (kbd "C-c <C-right>") (ignore-error-wrapper 'windmove-right))
;  (global-set-key (kbd "C-c <C-up>") (ignore-error-wrapper 'windmove-up))
;  (global-set-key (kbd "C-c <C-down>") (ignore-error-wrapper 'windmove-down))

  (global-set-key (kbd "C-c <C-left>") 'windmove-left)
  (global-set-key (kbd "C-c <C-right>") 'windmove-right)
  (global-set-key (kbd "C-c <C-up>") 'windmove-up)
  (global-set-key (kbd "C-c <C-down>") 'windmove-down)
#+END_SRC
*** Window minimize/maximize
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c -") 'minimize-window)
(global-set-key (kbd "C-c +") 'maximize-window)
#+END_SRC
*** Window resizing
#+BEGIN_SRC emacs-lisp
(defun shrink-window-horizontally-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (shrink-window-horizontally 10))

(defun enlarge-window-horizontally-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (enlarge-window-horizontally 10))

(defun shrink-window-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (shrink-window 10))

(defun enlarge-window-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (enlarge-window 10))

;; Window resize bindings.
(global-set-key (kbd "C-S-x <C-S-left>") 'shrink-window-horizontally-stepped)
(global-set-key (kbd "C-S-x <C-S-right>") 'enlarge-window-horizontally-stepped)
(global-set-key (kbd "C-S-x <C-S-down>") 'shrink-window-stepped)
(global-set-key (kbd "C-S-x <C-S-up>") 'enlarge-window-stepped)

(global-set-key (kbd "C-S-c <C-S-left>") 'shrink-window-horizontally)
(global-set-key (kbd "C-S-c <C-S-right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-S-c <C-S-down>") 'shrink-window)
(global-set-key (kbd "C-S-c <C-S-up>") 'enlarge-window)
#+END_SRC
*** Minibuffer
#+BEGIN_SRC emacs-lisp
(defun switch-to-minibuffer ()
  "Switch to minibuffer window."
  (interactive)
  (if (active-minibuffer-window)
      (select-window (active-minibuffer-window))
    (error "Minibuffer is not active")))

;; Switch to minibuffer.
(global-set-key (kbd "C-x M") 'switch-to-minibuffer)
#+END_SRC
*** Ivy, Counsel
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :diminish ivy-mode
  :config (global-set-key (kbd "C-x b") 'ivy-switch-buffer)
          (global-set-key (kbd "C-c C-r") 'ivy-resume)
          (global-set-key (kbd "<f6>") 'ivy-resume))

(use-package counsel
  :ensure t
  :diminish counsel-mode
  :config (global-set-key (kbd "M-x") 'counsel-M-x)
          (global-set-key (kbd "C-x C-f") 'counsel-find-file)
          (global-set-key (kbd "C-x C-S-r") 'counsel-recentf)
          (global-set-key (kbd "<f1> f") 'counsel-describe-function)
          (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
          (global-set-key (kbd "<f1> l") 'counsel-load-library)
          (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
          (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
          (global-set-key (kbd "C-c g") 'counsel-git)
          (global-set-key (kbd "C-c j") 'counsel-git-grep)
          (global-set-key (kbd "C-c a") 'counsel-ag)
          (global-set-key (kbd "C-c l") 'counsel-locate)
          (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
          (define-key read-expression-map (kbd "C-r") 'counsel-expression-history))

(use-package counsel-projectile
  :ensure t
  :diminish counsel-projectile-mode
  :config (counsel-projectile-mode))
#+END_SRC
*** Mark
**** Selection
#+BEGIN_SRC emacs-lisp
(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(defun jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))

;; Mark without select visible.
(global-set-key (kbd "C-`") 'push-mark-no-activate)
(global-set-key (kbd "C-~") 'jump-to-mark)
#+END_SRC
**** Convenience mapping for navigating back to your previous editing spots
#+BEGIN_SRC emacs-lisp
;; Does C-U C-SPC programatically.
(defun set-mark-command-prefix-arg ()
  (interactive)
  (setq current-prefix-arg '(4)) ; C-u
  (call-interactively 'set-mark-command))

(global-set-key (kbd "<s-SPC>") 'set-mark-command-prefix-arg)
#+END_SRC
*** Tabs
#+BEGIN_SRC emacs-lisp
;; Tab indentation width.
(setq tab-width 4)
#+END_SRC
*** Speedbar
#+BEGIN_SRC emacs-lisp
(global-set-key [f11] 'speedbar)
#+END_SRC
*** Default browser
You can set Firefox to open all external links in the same tab.

 - Enter about:config in the address bar.
 - Click the confirmation button if shown.
 - Filter for browser.link.open_newwindow.
 - Double click.
 - Set value to 1.
 - OK.
#+BEGIN_SRC emacs-lisp
  ;; (setq browse-url-browser-function 'browse-url-generic
  ;;       browse-url-generic-program "xdg-open")

(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "firefox")

  ;; (setq browse-url-browser-function 'browse-url-generic
  ;;       browse-url-generic-program "xdg-open")

  ;; (setq browse-url-browser-function 'browse-url-chromium
  ;;       browse-url-generic-program "chromium")
  ;; (defun browse-url-chromium (url &optional new-window)
  ;;  "Open URL in a new Chromium window."
  ;;  (interactive (browse-url-interactive-arg "URL: "))
  ;;  (unless
  ;;      (string= ""
  ;;               (shell-command-to-string
  ;;                (concat "chromium " url)))
  ;;    (message "Starting Chromium...")
  ;;    (start-process (concat "chromium " url) nil "chromium " url)
  ;;    (message "Starting Chromium... done")))
#+END_SRC
** Break & Debug
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-M-g") 'top-level)
; (toggle-debug-on-quit)
#+END_SRC
** Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC
** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
#+END_SRC
** Revert buffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-M-f") 'revert-buffer)
#+END_SRC
** Large files
#+BEGIN_SRC emacs-lisp
;; Large files slow emacs down to a grind. Main offender is fundamental mode.
(defun my-find-file-check-make-large-file-read-only-hook ()
  "If a file is over a given size, make the buffer read only."
  (when (> (buffer-size) (* 1024 1024))
    ;;(setq buffer-read-only t)
    ;;(buffer-disable-undo)
    (fundamental-mode)))

(add-hook 'find-file-hook 'my-find-file-check-make-large-file-read-only-hook)
#+END_SRC
** Disable auto save and -backup
#+BEGIN_SRC emacs-lisp
;disable backup
(setq backup-inhibited t)
;disable auto save
(setq auto-save-default nil)
#+END_SRC
** sudo-edit
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
  :ensure t
  :bind
    ("C-M-e" . sudo-edit))
#+END_SRC
** async
#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :init (dired-async-mode 1))
#+END_SRC
** dmenu
#+BEGIN_SRC emacs-lisp
(use-package dmenu
  :ensure t)
(global-set-key (kbd "C-c d") 'dmenu)
#+END_SRC
** Follow created window
[[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org]]
#+BEGIN_SRC emacs-lisp
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC
** Swiper
Retrying Swiper (is it now faster with big files?)
#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind ("C-=" . 'swiper))
#+END_SRC
** ibuffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
;; (setq ibuffer-expert t)
#+END_SRC
** Kill current buffer
https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org
#+BEGIN_SRC emacs-lisp
(defun kill-current-buffer ()
  "Kills the current buffer."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC
** Kill all buffers
https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org
#+BEGIN_SRC emacs-lisp
(defun close-all-buffers ()
  "Kill all buffers without regard for their origin."
  (interactive)
  (mapc 'kill-buffer (buffer-list)))
(global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC
** Kill ring
*** Size
#+BEGIN_SRC emacs-lisp
(setq kill-ring-max 100)
#+END_SRC
*** Clear
#+BEGIN_SRC emacs-lisp
(defun clear-kill-ring ()
  (interactive)
  (setq kill-ring nil)
  (garbage-collect))
(global-set-key (kbd "s-y") 'clear-kill-ring)
#+END_SRC
*** popup-kill-ring
#+BEGIN_SRC emacs-lisp
(use-package popup-kill-ring
  :ensure t
  :bind ("M-y" . popup-kill-ring))
#+END_SRC
** Bash
#+BEGIN_SRC emacs-lisp
(defvar my-term-shell "/bin/bash")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
(global-set-key (kbd "C-c t") 'ansi-term)
#+END_SRC
** Time
#+BEGIN_SRC emacs-lisp
(setq display-time-24hr-format t)
(setq display-time-format "%H:%M - %d %B %Y")
(display-time-mode 1)
#+END_SRC
** Alsa
*** Volume controls
This appears to be done by the =desktop-environment= package.
Replace EXAMPLE with SRC emacs-lisp to enable.
#+BEGIN_EXAMPLE
(defun audio/mute ()
  (interactive)
  (start-process "audio-mute" nil "amixer" "-q" "sset" "Master" "toggle"))

(defun audio/raise-volume ()
  (interactive)
  (start-process "raise-volume" nil "amixer" "-q" "sset" "Master" "10%+"))

(defun audio/lower-volume ()
  (interactive)
(start-process "lower-volume" nil "amixer" "-q" "sset" "Master" "10%-"))

(global-set-key (kbd "<XF86AudioMute>") 'audio/mute)
(global-set-key (kbd "<XF86AudioRaiseVolume>") 'audio/raise-volume)
(global-set-key (kbd "<XF86AudioLowerVolume>") 'audio/lower-volume)
#+END_EXAMPLE
* TODO exwm
Move this into a separate Emacs configuration and start it via
=HOME=pathtoseparateemacsd emacs &= to separate from regular Emacs.
** Emacs Window Manager
Replace EXAMPLE with SRC emacs-lisp to enable =exwm= (which is very
nice indeed, but I'm afraid it'll give me carpal tunnel syndrome;
sticking to KDE + tiling shortcuts).

Wiki: [[https://github.com/ch11ng/exwm/wiki][EXWM wiki]].
#+BEGIN_EXAMPLE
(use-package exwm
  :ensure t
  :config
    ;; necessary to configure exwm manually
    (require 'exwm-config)

    ;; fringe size, most people prefer 1
    (fringe-mode 3)

    ;; emacs as a daemon, use "emacsclient <filename>" to seamlessly edit files from the terminal directly in the exwm instance
    (server-start)

    ;; this fixes issues with ido mode (e.g. dmenu not fully showing), if you use helm, get rid of it
    ;(exwm-enable-ido-workaround)
    (exwm-config-ido)

    ;; a number between 1 and 9, exwm creates workspaces dynamically; start out with 2 (multiple monitor).
    (setq exwm-workspace-number 2)

    ;; Workspaces.
    (setq exwm-workspace-show-all-buffers t)
    (setq exwm-layout-show-all-buffers t)

    ;; reize windows with mouse.
    (setq window-divider-default-right-width 1)
    (window-divider-mode)

    ; Rename buffer to window title (Otherwise EXWM#).
    (defun exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))
    (add-hook 'exwm-update-title-hook 'exwm-rename-buffer-to-title)

    ;; this is a way to declare truly global/always working keybindings
    ;; this is a nifty way to go back from char mode to line mode without using the mouse
    (exwm-input-set-key (kbd "s-r") #'exwm-reset)
    (exwm-input-set-key (kbd "s-k") #'exwm-workspace-delete)
    (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)
    (exwm-input-set-key (kbd "s-s") #'exwm-workspace-swap)
    (exwm-input-set-key (kbd "s-b") #'exwm-workspace-switch-to-buffer)
    (exwm-input-set-key (kbd "s-m") #'exwm-workspace-move-window)
    (exwm-input-set-key (kbd "s-x") #'exwm-randr-refresh)
    (exwm-input-set-key (kbd "s-f") #'exwm-layout-set-fullscreen)
    (exwm-input-set-key (kbd "s-d") #'dmenu)

    ;; the next loop will bind s-<number> to switch to the corresponding workspace
    (dotimes (i 10)
      (exwm-input-set-key (kbd (format "s-%d" i))
                          `(lambda ()
                             (interactive)
                             (exwm-workspace-switch-create ,i))))

   ;; Workspace previous/next; see snippet at: https://emacs.stackexchange.com/questions/33105/in-exwm-emacs-x-window-manager-how-can-i-switch-to-previous-workspace

   (defvar exwm-workspace-latest-index nil "The previous active workspace index.")

   (defun exwm-workspace-current-to-latest-index (_x)
     (setq exwm-workspace-latest-index exwm-workspace-current-index))

   (advice-add 'exwm-workspace-switch :before #'exwm-workspace-current-to-latest-index)

   (defun exwm-workspace-switch-to-latest ()
     (interactive)
     "Switch to the latest active workspace."
     (let ((index exwm-workspace-latest-index))
       (exwm-workspace-switch index)))

   (defun exwm-workspace-switch-to-previous ()
     "Switch to the previous workspace."
     (interactive)
     (let ((index exwm-workspace-current-index))
       (exwm-workspace-switch (if (> index 0) (- index 1) index))))

   (defun exwm-workspace-switch-to-next ()
     "Switch to the next workspace."
     (interactive)
     (let ((index exwm-workspace-current-index))
       (exwm-workspace-switch (+ index 1))))

   (exwm-input-set-key (kbd "s-\\") #'exwm-workspace-switch-to-latest)
   (exwm-input-set-key (kbd "s-[") #'exwm-workspace-switch-to-previous)
   (exwm-input-set-key (kbd "s-]") #'exwm-workspace-switch-to-next)
   (exwm-input-set-key (kbd "<s-iso-lefttab>") #'exwm-workspace-switch-to-previous)
   (exwm-input-set-key (kbd "<s-tab>") #'exwm-workspace-switch-to-next)

   ;; the simplest launcher, I keep it in only if dmenu eventually stopped working or something
   (exwm-input-set-key (kbd "s-&")
                       (lambda (command)
                         (interactive (list (read-shell-command "$ ")))
                         (start-process-shell-command command nil command)))

    ;; an easy way to make keybindings work *only* in line mode
    (push ?\C-q exwm-input-prefix-keys)
    (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

    ;; simulation keys are keys that exwm will send to the exwm buffer upon inputting a key combination
    (exwm-input-set-simulation-keys
     '(
       ;; movement
       ([?\C-b] . left)
       ([?\M-b] . C-left)
       ([?\C-f] . right)
       ([?\M-f] . C-right)
       ([?\C-p] . up)
       ([?\C-n] . down)
       ([?\C-a] . home)
       ([?\C-e] . end)
       ([?\M-v] . prior)
       ([?\C-v] . next)
       ([?\C-d] . delete)
       ([?\C-k] . (S-end delete))
       ;; select/cut/paste
       ;([?\C-x ?h] . ?\C-a) ; only works in emacs 27+ -- https://github.com/ch11ng/exwm/issues/348
       ([?\M-a] . ?\C-a) ; workaround
       ([?\C-w] . ?\C-x)
       ([?\M-w] . ?\C-c)
       ([?\C-y] . ?\C-v)
       ;; search
       ([?\C-s] . ?\C-f)))

    ;; Commented out because desktop-environment package apparently supplies this.
    ;; this little bit will make sure that XF86 keys work in exwm buffers as well
    ;(dolist (k '(XF86AudioLowerVolume
    ;           XF86AudioRaiseVolume
    ;           XF86PowerOff
    ;           XF86AudioMute
    ;           XF86AudioPlay
    ;           XF86AudioStop
    ;           XF86AudioPrev
    ;           XF86AudioNext
    ;           XF86ScreenSaver
    ;           XF68Back
    ;           XF86Forward
    ;           Scroll_Lock
    ;           print))
    ;(cl-pushnew k exwm-input-prefix-keys))

    ;(setq exwm-randr-workspace-output-plist '(0 "LVDS-1" 1 "HDMI-1"))
)

;;TODO! Check environment variable DESKTOP_SESSION=exwm to determine if enable.
;; this just enables exwm, it started automatically once everything is ready
(require 'exwm-systemtray)
(message "Enabling EXWM SYSTEMTRAY.")
(exwm-systemtray-enable)

(require 'exwm-randr)

;; Snippet taken from RandR (multi-screen) at: https://github.com/ch11ng/exwm/wiki
;; and converted to two active screens. Also added call to exwm-randr-refresh.
(defun exwm-change-screen-hook ()
  (let ((xrandr-output-regexp "\n\\([^ ]+\\) connected ")
        primary-output)
    (with-temp-buffer
      (call-process "xrandr" nil t nil)
      (goto-char (point-min))
      (re-search-forward xrandr-output-regexp nil 'noerror)
      (setq primary-output (match-string 1))
      (forward-line)
      (setq multiple-outputs (re-search-forward xrandr-output-regexp nil 'noerror))
      (if (not multiple-outputs)
        (call-process "xrandr" nil nil nil "--output" primary-output "--auto")
        (call-process
          "xrandr" nil nil nil
          "--output" (match-string 1) "--primary" "--auto"
          "--output" primary-output "--auto" "--right-of" (match-string 1)))
        (setq exwm-randr-workspace-output-plist (if multiple-outputs
                                                  (list 0 primary-output 1 (match-string 1))
                                                  (list 0 primary-output)))
        (exwm-randr-refresh))))

(add-hook 'exwm-randr-screen-change-hook 'exwm-change-screen-hook)

;;TODO! Check environment variable DESKTOP_SESSION=exwm to determine if enable.
(message "Enabling EXWM RANDR.")
(exwm-randr-enable)

;;TODO! Check environment variable DESKTOP_SESSION=exwm to determine if enable.
(message "Enabling EXWM.")
(exwm-enable)
#+END_EXAMPLE
** desktop-environment
Replace EXAMPLE with SRC emacs-lisp to enable.
Extension package for e.g. volume keys and screen lock with s-l.
#+BEGIN_EXAMPLE
(use-package desktop-environment
  :diminish desktop-environment-mode
  :ensure t
  :config (if window-system
            (desktop-environment-mode)))
#+END_EXAMPLE
** Battery monitor
Replace EXAMPLE with SRC emacs-lisp to enable.
#+BEGIN_EXAMPLE
(use-package fancy-battery
  :ensure t
  :config
    (setq fancy-battery-show-percentage t)
    (setq battery-update-interval 15)
    (if window-system
      (fancy-battery-mode)
      (display-battery-mode)))
#+END_EXAMPLE
** System monitor
Replace EXAMPLE with SRC emacs-lisp to enable.
#+BEGIN_EXAMPLE
(use-package symon
  :ensure t
  :diminish symon-mode
  :config
    (setq symon-monitors '(symon-current-time-monitor
                           symon-linux-memory-monitor
                           symon-linux-cpu-monitor
                           symon-linux-network-rx-monitor
                           symon-linux-network-tx-monitor))
    (symon-mode)
  :bind
  ("s-h" . symon-mode))
#+END_EXAMPLE
* evil
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t)

;(require 'evil)
;(evil-mode 1)
(define-key projectile-mode-map (kbd "M-+") 'evil-mode)
#+END_SRC
* Org-mode
Org-mode is an Emacs built-in.
** TODO Shortcuts
#+BEGIN_SRC emacs-lisp
;;TODO
;;(require 'org)
;;(define-key global-map "\C-cl" 'org-store-link)
;;(define-key global-map "\C-ca" 'org-agenda)
;;(setq org-log-done t)

(define-key org-mode-map (kbd "<C-M-tab>") 'pcomplete)
#+END_SRC
** TODO org-bullets
Disabled this because it results in 100% CPU usage.
#+BEGIN_SRC emacs-lisp
;; (use-package org-bullets
;;   :ensure t
;;   :diminish org-bullets-mode
;;   :config
;;     (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC
** Exports
#+BEGIN_SRC emacs-lisp
(use-package ox-twbs
  :ensure t)
#+END_SRC
** Indentation
#+BEGIN_SRC emacs-lisp
;TODO CHECK ERROR: symbol's function definition is void: diminish
;(eval-after-load "org-indent" '(diminish 'org-indent-mode))
#+END_SRC
** HTMLize buffers
When exporting documents to HTML documents, such as code fragments, we need to htmlize.
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t)
#+END_SRC
** TODO Reveal.js
Tool to create presentations via an emacs org file export. See: [[https://github.com/emacsmirror/org-re-reveal]].
Replace EXAMPLE with SRC emacs-lisp to enable.
#+BEGIN_EXAMPLE
;;TODO doesn't appear to work (breaks org-mode export of title sections).
(use-package org-re-reveal
  :ensure t)

;; Reveal.js location and ox-reveal.
;;(setq org-reveal-root "file:///home/mdo/lib/reveal.js")
;;(setq org-reveal-mathjax t)
#+END_EXAMPLE
* Comma Separated Files
#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :ensure t)
#+END_SRC
* Mediawiki
MediaWiki mode.
#+BEGIN_SRC emacs-lisp
(use-package mediawiki
  :ensure t)
#+END_SRC
* Edit indirect
The edit-indirect package is used by Markdown for editing code blocks.
#+BEGIN_SRC emacs-lisp
(use-package edit-indirect
  :ensure t)
#+END_SRC
* Markdown
Markdown is a great way to write documentation, not as good as
org-mode of course, but generally accepted as a standard.
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t)
#+END_SRC
* AsciiDoc
[[http://www.methods.co.nz/asciidoc/][AsciiDoc]] is an alternative way to write documentation, not as good as
org-mode of course, but supported by e.g. github. The [[https://github.com/sensorflo/adoc-mode/wiki][adoc-mode]] Emacs
major mode supports the adoc format.
#+BEGIN_SRC emacs-lisp
(use-package adoc-mode
  :ensure t)

(add-to-list 'auto-mode-alist (cons "\\.adoc\\'" 'adoc-mode))
(add-hook 'adoc-mode-hook (lambda() (buffer-face-mode t)))
#+END_SRC
* LaTex
This installs the [[https://www.gnu.org/software/auctex/][auctex]] and [[https://github.com/tom-tan/auctex-latexmk][auctex-latexmk]] packages.
#+BEGIN_SRC emacs-lisp
(use-package tex
    :ensure auctex
    :config (setq TeX-auto-save t)
            (setq TeX-parse-self t)
            (setq TeX-save-query nil)
            (setq latex-run-command "pdflatex"))
;;(setq TeX-PDF-mode t)
(require 'tex)

(use-package auctex-latexmk
    :ensure auctex-latexmk)
(require 'auctex-latexmk)
(auctex-latexmk-setup)
(setq auctex-latexmk-inherit-TeX-PDF-mode t)
#+END_SRC
* Programming
** General
Setup for GNU Emacs, Clojure and ClojureScript. Plus [[https://github.com/Fuco1/smartparens][Smartparens]].

The structured editing of smartparens is useful in a LOT of languages, as
long as there are parenthesis, brackets or quotes.
*** Utilities
String manipulation routines for emacs lisp
#+BEGIN_SRC emacs-lisp
(use-package s
  :ensure t)
#+END_SRC
*** Smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config (progn (show-smartparens-global-mode t))
                 (add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)
                 (add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-strict-mode)
                 (add-hook 'ielm-mode-hook #'smartparens-strict-mode)
                 (add-hook 'lisp-mode-hook #'smartparens-strict-mode)
                 (add-hook 'lisp-interaction-mode-hook #'smartparens-strict-mode)
                 (add-hook 'scheme-mode-hook #'smartparens-strict-mode)
  :bind (("<f7>" . smartparens-strict-mode)
         ("C-S-s a" . sp-beginning-of-sexp)
         ("C-S-s e" . sp-end-of-sexp)
         ("C-S-s d" . sp-down-sexp)
         ("C-S-s u" . sp-up-sexp)
         ("C-S-s D" . sp-backward-down-sexp)
         ("C-S-s U" . sp-up-down-sexp)
         ("C-S-s f" . sp-forward-sexp)
         ("C-S-s b" . sp-backward-sexp)
         ("C-M-<right>" . sp-next-sexp)
         ("C-M-<left>" . sp-previous-sexp)
         ("C-S-s S" . sp-backward-symbol)
         ("C-S-s s" . sp-forward-symbol)
         ("C-S-s |" . sp-split-sexp)
         ("C-S-s U" . sp-backward-unwrap-sexp)
         ("C-S-s u" . sp-unwrap-sexp)
         ("M-<right>" . sp-forward-slurp-sexp)
         ("M-S-<right>" . sp-forward-barf-sexp)
         ("M-<left>" . sp-backward-slurp-sexp)
         ("M-S-<left>" . sp-backward-barf-sexp)
         ("C-S-s t" . sp-transpose-sexp)
         ("C-S-s k" . sp-kill-sexp)
         ("C-S-s h" . sp-kill-hybrid-sexp)
         ("C-S-s K" . sp-backward-kill-sexp)))
#+END_SRC
*** Highlight parentheses
#+BEGIN_SRC emacs-lisp
(use-package highlight-parentheses
  :ensure t
  :diminish highlight-parentheses-mode
  :config (add-hook 'emacs-lisp-mode-hook
            (lambda() (highlight-parentheses-mode))))

(global-highlight-parentheses-mode)
#+END_SRC
*** Rainbow
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  :diminish rainbow-mode
  :init
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC
*** Rainbow delimiters
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :diminish rainbow-delimiters-mode
  :config (add-hook 'lisp-mode-hook
              (lambda() (rainbow-delimiters-mode)))
          (add-hook 'clojure-mode-hook
              (lambda() (rainbow-delimiters-mode)))
          (add-hook 'clojurec-mode-hook
              (lambda() (rainbow-delimiters-mode)))
          (add-hook 'clojurescript-mode-hook
              (lambda() (rainbow-delimiters-mode))))

(global-highlight-parentheses-mode)
#+END_SRC

*** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :config (yas/global-mode 1)
          (add-to-list 'yas-snippet-dirs (concat init-dir "snippets"))
          (add-hook 'web-mode-hook #'(lambda () (yas-activate-extra-mode 'html-mode)))
          (add-hook 'web-mode-hook #'(lambda () (yas-activate-extra-mode 'css-mode))))

(use-package clojure-snippets
  :ensure t)
#+END_SRC
*** Auto completion
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  ;;:diminish company-mode
  :bind (("<C-M-return>" . company-complete))
  :config (global-company-mode))
#+END_SRC
*** Code folding
#+BEGIN_SRC emacs-lisp
(use-package origami
  :ensure t
  :diminish origami-mode
  :config (global-origami-mode)
  :bind (("C-c |" . origami-reset)
         ("C-c {" . origami-open-node-recursively)
         ("C-c }" . origami-close-node-recursively)
         ("C-c \"" . origami-toggle-all-nodes)))
#+END_SRC
*** Version Control
Magit is the only thing you need when it comes to Version Control (Git)

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status)))
#+END_SRC

*** Projectile
#+BEGIN_SRC emacs-lisp
;; Project based navigation and search. Note also the .projectile file that
;; can be placed in the root of a project. It can be used to exclude (or include)
;; directories (see: https://github.com/bbatsov/projectile).
(use-package projectile
  :ensure t
  :diminish projectile-mode)

(projectile-mode +1)
(define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+END_SRC
*** REST (client) support
#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t)
#+END_SRC

*** Imenu
#+BEGIN_SRC emacs-lisp
;; Add imenu to menu bar and make it automatically rescan.
(add-hook 'clojure-mode-hook #'imenu-add-menubar-index)
(add-hook 'clojurec-mode-hook #'imenu-add-menubar-index)
(add-hook 'clojurescript-mode-hook #'imenu-add-menubar-index)
(setq imenu-auto-rescan 1)

;; Incremental imenu.
(global-set-key (kbd "C-S-l") 'imenu)
#+END_SRC
*** Symbols
**** TODO Highlight s-exp
#+BEGIN_SRC emacs-lisp
; (use-package hl-sexp
;   :ensure t
;   :config (add-hook 'lisp-mode-hook #'hl-sexp-mode)
;           (add-hook 'emacs-lisp-mode-hook #'hl-sexp-mode)
;   :bind (("C-M-'" . hl-sexp-mode)))
#+END_SRC
**** Highlight symbol
Global highlight code taken from [[https://github.com/nschum/highlight-symbol.el/issues/11]].
#+BEGIN_SRC emacs-lisp
(defun highlight-symbol-mode-on () (highlight-symbol-mode 1))
(define-globalized-minor-mode global-highlight-symbol-mode
                              highlight-symbol-mode
                              highlight-symbol-mode-on)

(use-package highlight-symbol
  :ensure t
  :diminish highlight-symbol-mode
  :config (setq highlight-symbol-idle-delay  0.5)
  :bind (("C-*" . highlight-symbol)
         ("M-*" . highlight-symbol-remove-all)
         ("<f5>" . highlight-symbol-next)
         ("S-<f5>" . highlight-symbol-prev)
         ("M-<f5>" . highlight-symbol-query-replace)))

;;WARNING: interferes with Magit faces. (do not use global mode).
;;(global-highlight-symbol-mode 1)
#+END_SRC
*** Re-map xref keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-M-.") 'xref-find-definitions)
(global-set-key (kbd "C-M-,") 'xref-pop-marker-stack)
#+END_SRC
*** Dumb-jump
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t
  :diminish dumb-jump-mode
  :bind (("C-." . dumb-jump-go)
         ("C-," . dumb-jump-back)))
#+END_SRC
*** TODO hl-line
This interferes with search colors.
#+BEGIN_SRC emacs-lisp
;(when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC
** TODO Flycheck syntax checker
This apparently intervenes with haskell-language-server (unrecognized modules).
#+BEGIN_SRC emacs-lisp
  ;;(use-package flycheck
  ;;  :ensure t
  ;;  :diminish flycheck-mode
  ;;  :bind (("C-C >" . flycheck-next-error)
  ;;         ("C-C <" . flycheck-previous-error)
  ;;         ("C-C ?" . flycheck-list-errors)))

  ;;(add-hook 'prog-mode-hook #'flycheck-mode)
#+END_SRC
** Clojure
The clojure ecosystem for GNU Emacs consists out of CIDER and bunch of
supporting modules.
*** Cider
#+BEGIN_SRC emacs-lisp
(use-package cider
  :ensure t
  :diminish cider-mode
  :pin melpa-stable
  :init (setq cider-show-error-buffer t
              cider-auto-select-error-buffer t
              ;;cider-repl-pop-to-buffer-on-connect nil
              cider-repl-use-clojure-font-lock t
              cider-repl-wrap-history t
              cider-repl-history-file "~/.emacs.d/cider-history"
              cider-repl-history-size 999
              cider-repl-use-pretty-printing t
              nrepl-hide-special-buffers t
              ;; Stop error buffer from popping up while working in buffers other than the REPL:
              nrepl-popup-stacktraces nil)

        (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
        (add-hook 'cider-repl-mode-hook #'company-mode)
        (add-hook 'cider-mode-hook #'company-mode)
        (add-hook 'cider-mode-hook #'eldoc-mode)

;;  :config (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
;;          (add-hook 'cider-repl-mode-hook #'company-mode)
;;          (add-hook 'cider-mode-hook #'company-mode)
;;          (add-hook 'cider-mode-hook #'eldoc-mode)
;;          (setq cider-repl-history-file "~/.emacs.d/cider-history")
;;          (setq cider-repl-use-clojure-font-lock t)
;;          (setq cider-repl-result-prefix ";; => ")
;;          (setq cider-repl-wrap-history t)
;;          (setq cider-repl-history-size 9999)
;;          (setq cider-repl-use-pretty-printing t)
;;          (setq cider-repl-display-help-banner nil)
;;          ;(setq cider-cljs-lein-repl "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))")

  :bind (("M-r" . cider-namespace-refresh)
         ("C-c r" . cider-repl-reset)
         ("C-c ." . cider-reset-test-run-tests)
         ("C-c C-v C-e" . cider-eval-defun-at-point)
         ;("M-<return>" . cider-doc)
         ("<f8>" . cider-clear-compilation-highlights)))

(require 'clojure-mode)
(define-key clojure-mode-map (kbd "M-<return>") 'cider-doc)

;; Scrolling behaviour has changed in more recent Cider versions; fix it.
(add-hook 'cider-repl-mode-hook '(lambda () (setq scroll-conservatively 101)))

(add-hook 'clojure-mode-hook #'smartparens-strict-mode)
(add-hook 'clojurec-mode-hook #'smartparens-strict-mode)
(add-hook 'clojurescript-mode-hook #'smartparens-strict-mode)
(add-hook 'clojure-mode-hook #'highlight-symbol-mode)
#+END_SRC
*** Indentation customization
See documentation [[https://github.com/clojure-emacs/clojure-mode/][clojure-mode]]. Below are customizations for specific indentations.
#+BEGIN_SRC emacs-lisp
(put-clojure-indent '>defn 2)
#+END_SRC
*** Hoplon
Taken from: [[https://github.com/hoplon/hoplon/wiki/For-Emacs-users][Hoplon for Emacs users]].

To recognize hoplon files correctly add this to your .emacs
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.cljs\\.hl" . clojurescript-mode))
#+END_SRC

To properly indent hoplon macros. The following is extended from Alan's dotspacemacs:
#+BEGIN_SRC emacs-lisp
(add-hook 'clojure-mode-hook
            '(lambda ()
               ;; Hoplon functions and macros
               (dolist (pair '((page . 'defun)
                               (loop-tpl . 'defun)
                               (if-tpl . '1)
                               (for-tpl . '1)
                               (case-tpl . '1)
                               (cond-tpl . 'defun)))
                 (put-clojure-indent (car pair)
                                     (car (last pair))))))
#+END_SRC
*** clj-refactor
Replace EXAMPLE with SRC emacs-lisp to enable.
#+BEGIN_EXAMPLE
(use-package clj-refactor
  :pin melpa-stable
  :ensure t
  :diminish clj-refactor-mode
  :init
  (add-hook 'clojure-mode-hook 'clj-refactor-mode)
  :config
  ;; Configure the Clojure Refactoring prefix:
  (cljr-add-keybindings-with-prefix "C-c C-/")
  :diminish clj-refactor-mode)
#+END_EXAMPLE
*** Expand region
#+BEGIN_SRC emacs-lisp
;expand-region functionality is really great for lisp/clojure editing
;from https://github.com/magnars/expand-region.el
(use-package expand-region
  :ensure t
  :bind ("C-x x" . er/expand-region))
#+END_SRC
** Python
*** elpy
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t)

(add-hook 'python-mode-hook 'highlight-symbol-mode)
#+END_SRC
** nix-mode
#+BEGIN_SRC emacs-lisp
(use-package nix-mode
  :ensure t)
#+END_SRC
** Haskell
See: [[https://blog.sumtypeofway.com/posts/emacs-config.html][My Emacs Configuration (Or, Emacs is Agar for Brain Worms) - 2020-09-14]]
*** TODO company-ghci
Not necessary with eglot.
#+BEGIN_SRC emacs-lisp
;;(use-package company-ghci
;;    :ensure t)
#+END_SRC
*** ormolu
#+BEGIN_SRC emacs-lisp
(use-package ormolu
    :ensure t)
#+END_SRC
*** haskell-mode
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
    :ensure t
    :config
    ;; haskell-mode doesn't know about newer GHC features.
    (let ((new-extensions '("QuantifiedConstraints"
                            "DerivingVia"
                            "BlockArguments"
                            "DerivingStrategies"
                            "StandaloneKindSignatures"
                            )))
      (setq
       haskell-ghc-supported-extensions
       (append haskell-ghc-supported-extensions new-extensions)))
    :bind ("C-x c c" . haskell-cabal-visit-file)
          ("C-x c i" . haskell-navigate-imports)
          ("C-x c I" . haskell-navigate-imports-return)
          ("C-c C-z" . haskell-interactive-switch)
          ("C-c o" . haskell-hoogle)
          ("<C-return>" . haskell-process-do-info)
          ;; ("M-F" . haskell-mode-stylish-buffer)
          ("M-F" . ormolu-format-buffer)
          ;;("<C-M-return>" . company-ghci)
          ("C-c SPC" . flymake-show-diagnostics-buffer)
          ("C-c <up>" . flymake-goto-prev-error)
          ("C-c <down>" . flymake-goto-next-error)
          )
#+END_SRC
See here for setup: [[https://stackoverflow.com/questions/56501112/haskell-emacs-haskell-mode-run-c-h-f-haskell-mode-for-instruction-how-to-setu][Haskell Emacs haskell-mode: Run 'C-h f haskell-mode' for instruction how to setup a Haskell interaction mode]].
*** hindent
#+BEGIN_SRC emacs-lisp
(use-package hindent
    :ensure t)
#+END_SRC
*** eglot
See: [[https://github.com/joaotavora/eglot][Emacs Polyglot: an Emacs LSP client that stays out of your way]]
#+BEGIN_SRC emacs-lisp
(use-package eglot
    :ensure t)

(add-to-list 'eglot-server-programs '(haskell-mode . ("haskell-language-server-wrapper" "--lsp")))
;; To enable by default remove the comment.
;;(add-hook 'haskell-mode-hook 'eglot-ensure)

(setq eldoc-echo-area-use-multiline-p 6)
(setq eldoc-prefer-doc-buffer t)
(define-key eglot-mode-map (kbd "<M-return>") 'eldoc-print-current-symbol-info)
#+END_SRC
*** haskell-snippets
#+BEGIN_SRC emacs-lisp
(use-package haskell-snippets
    :ensure t
    :after (haskell-mode yasnippet)
    :defer)
#+END_SRC
** HLedger
#+BEGIN_SRC emacs-lisp
(use-package hledger-mode
    :ensure t)
(add-to-list 'auto-mode-alist '("\\.journal\\'" . hledger-mode))
#+END_SRC
** GraphQL
#+BEGIN_SRC emacs-lisp
(use-package graphql-mode
    :ensure t)
#+END_SRC
** Rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode
    :pin melpa-stable
    :ensure t)
#+END_SRC
** JSON
#+BEGIN_SRC emacs-lisp
(use-package json-mode
    :ensure t)
#+END_SRC
** HTML/CSS
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :diminish web-mode)
#+END_SRC
Package [[https://github.com/smihica/emmet-mode][emmet-mode]].
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :diminish emmet-mode)

(add-hook 'web-mode-hook 'emmet-mode)  ;; Auto-start on web-mode.
(add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes.
(add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.
#+END_SRC
** PHP
*** Drupal mode
#+BEGIN_SRC emacs-lisp
(use-package drupal-mode
  :ensure t
  :diminish drupal-mode)
#+END_SRC
*** Geben (Xdebug)
#+BEGIN_SRC emacs-lisp
(use-package geben
  :ensure t
  :diminish geben)
#+END_SRC
*** web-mode
#+BEGIN_SRC emacs-lisp
(require 'web-mode)
(add-to-list 'auto-mode-alist '("\\.php" . web-mode))
(setq web-mode-engines-alist
  '(("php"    . "\\.phtml\\'")
    ("blade"  . "\\.blade\\."))
)
#+END_SRC
* Docker
Docker modes (file and compose).
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :pin melpa-stable
  :ensure t)

(use-package docker-compose-mode
  :pin melpa-stable
  :ensure t)
#+END_SRC
* Editing
** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind
    ("C-c c" . avy-goto-char))
#+END_SRC
** Words
*** Improved kill-word
Why on earth does a function called kill-word not .. kill a word. It instead deletes characters from your cursors position to the end of the word, let’s make a quick fix and bind it properly.

[[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org]]
#+BEGIN_SRC emacs-lisp
(defun daedreth/kill-inner-word ()
  "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))
(global-set-key (kbd "C-c w k") 'daedreth/kill-inner-word)
#+END_SRC
*** Improved copy-word
And again, the same as above but we make sure to not delete the source word.

[[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org]]
#+BEGIN_SRC emacs-lisp
(defun daedreth/copy-whole-word ()
  (interactive)
  (save-excursion
    (forward-char 1)
    (backward-word)
    (kill-word 1)
    (yank)))
(global-set-key (kbd "C-c w c") 'daedreth/copy-whole-word)
#+END_SRC

** Navigation convenience shortcuts
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-M-S-up>") 'scroll-up-line)
(global-set-key (kbd "<C-M-S-down>") 'scroll-down-line)
(global-set-key (kbd "<C-M-S-left>") 'previous-buffer)
(global-set-key (kbd "<C-M-S-right>") 'next-buffer)
#+END_SRC
** Navigation and S-exp
#+BEGIN_SRC emacs-lisp
;; Delete sexp.
(global-set-key (kbd "<C-S-delete>") 'kill-sexp)

;; Goto previous top level paren-block.
(global-set-key (kbd "M-p") 'outline-previous-visible-heading)
(global-set-key (kbd "M-n") 'outline-next-visible-heading)

;; C-arrow for word navigation.
(global-set-key (kbd "<C-left>") 'left-word)
(global-set-key (kbd "<C-right>") 'right-word)

;; Convenience key mappings for sexp navigation.
(global-set-key (kbd "C-x <left>") 'sp-backward-sexp)
(global-set-key (kbd "C-S-x <left>") 'sp-backward-up-sexp)
(global-set-key (kbd "C-x <right>") 'sp-forward-sexp)

;; Bury buffer (moves to end of buffer list).
(global-set-key (kbd "M-B") 'bury-buffer)
#+END_SRC
** Lines
*** Selecting
#+BEGIN_SRC emacs-lisp
(defun select-current-line ()
  "Select current line.
URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2015-02-07
"
  (interactive)
  (end-of-line)
  (set-mark (line-beginning-position)))

;; Select current line.
(global-set-key (kbd "C-|") 'select-current-line)
#+END_SRC
*** Joining
#+BEGIN_SRC emacs-lisp
(defun join-next-line ()
  "Join next line."
  (interactive)
  (forward-line 1)
  (join-line))

;; Join line.
(global-set-key (kbd "C-S-J") 'join-next-line)
#+END_SRC
*** Deleting
#+BEGIN_SRC emacs-lisp
(defun delete-line-or-region (&optional n)
  "Delete current line, or region if active."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (if use-region
        (delete-region (region-beginning) (region-end))
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
        (delete-region (line-beginning-position) (line-end-position))
        (kill-whole-line)))))

;; Delete region.
(global-set-key (kbd "C-S-D") 'delete-line-or-region)
(global-set-key (kbd "<M-delete>") 'delete-line-or-region)
#+END_SRC
*** TODO Commenting
Instead of this check out [[https://github.com/yuutayamada/commenter][commenter]] package.
#+BEGIN_SRC emacs-lisp
(defun comment-line-or-region (&optional n)
  "Comment current line, or region if active."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (if use-region
        (comment-region (region-beginning) (region-end))
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
        (comment-region (line-beginning-position) (line-end-position))))))

;; Comment current line or region.
(global-set-key (kbd "C-;") 'comment-line-or-region)
#+END_SRC
*** Move-dup
#+BEGIN_SRC emacs-lisp
  (use-package move-dup
    :ensure t)

  ;; Enable globally but disable for org-mode.
  (global-move-dup-mode)
  (add-hook 'org-mode-hook (lambda () (move-dup-mode 0)))
#+END_SRC
*** Truncating
#+BEGIN_SRC emacs-lisp
;; Disable line truncating by default (normally buffer local setting)
(set-default 'truncate-lines t)
#+END_SRC
*** Numbering
#+BEGIN_SRC emacs-lisp
;; No line numbers by default.
(global-linum-mode 0)
(set-default 'global-linum-mode 0)

;; Line numbers for programming.
(add-hook 'prog-mode-hook (lambda () (linum-mode 1)))
;(add-hook 'web-mode-hook (lambda () (linum-mode 1)))
#+END_SRC

*** Various
#+BEGIN_SRC emacs-lisp
;; Quick switch linum-mode.
(global-set-key (kbd "C-S-n") 'linum-mode)

;; Expand and replace region.
(global-set-key (kbd "C-$") 'expand-delete-line)

;; Turn off text wrapping in the middle of a word
(global-visual-line-mode 1)
#+END_SRC
** Change
*** Goto last change
#+BEGIN_SRC emacs-lisp
(use-package goto-last-change
  :ensure t)

(global-set-key (kbd "C-S-Q") 'goto-last-change)
#+END_SRC
*** Undo tree
#+BEGIN_SRC emacs-lisp
;; Adds a custom directory where some .el scripts are placed used in
;; this config file. Note that if you have .el scripts that exist on
;; Melpa, you don't need this directory. But I have an undo-tree
;; script (configured below) not on Melpa, so this is how you do it:
(add-to-list 'load-path (concat user-emacs-directory "macros-config"))

;; From http://www.emacswiki.org/emacs/UndoTree Script must exist in
;; the macros-config directory before proceeding (see above paragraph)
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :config (global-undo-tree-mode))

;; Replace regular undo and redo with respectively tree-undo and tree-redo.
(global-set-key (kbd "C-_") 'undo-tree-undo)
(global-set-key (kbd "C-/") 'undo-tree-undo)
(global-set-key (kbd "C-z") 'undo-tree-undo)

(global-set-key (kbd "M-_") 'undo-tree-redo)
(global-set-key (kbd "C-?") 'undo-tree-redo)
(global-set-key (kbd "C-S-Z") 'undo-tree-redo)

;; Undo tree visualize
(global-set-key (kbd "C-x u") 'undo-tree-visualize)
#+END_SRC
** Parenthesis
*** Matching
Emacs lisp code from: [[https://www.emacswiki.org/emacs/NavigatingParentheses][Navigating Parentheses]].
#+BEGIN_SRC emacs-lisp
(defun goto-match-paren (arg)
  "Go to the matching parenthesis if on parenthesis. Else go to the
   opening parenthesis one level up."
  (interactive "p")
  (cond ((looking-at "\\s\(") (forward-list 1))
        (t
         (backward-char 1)
         (cond ((looking-at "\\s\)")
                (forward-char 1) (backward-list 1))
               (t
                (while (not (looking-at "\\s("))
                  (backward-char 1)
                  (cond ((looking-at "\\s\)")
                         (message "->> )")
                         (forward-char 1)
                         (backward-list 1)
                         (backward-char 1)))
                  ))))))

(global-set-key (kbd "C-S-P") 'goto-match-paren)
#+END_SRC
** Whitespaces
#+BEGIN_SRC emacs-lisp
;; Trim trailing whitespaces in current buffer.
(global-set-key (kbd "C-S-W") 'delete-trailing-whitespace)
#+END_SRC
** Search
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-S-F") 'find-dired)
(global-set-key (kbd "C-%") 'replace-string)

(use-package ag
  :ensure t
  :diminish ag-mode)
#+END_SRC
** Scroll
#+BEGIN_SRC emacs-lisp
  ;; Scroll without changing point.
  (global-set-key (kbd "s-<") 'scroll-right)
  (global-set-key (kbd "s->") 'scroll-left)

  (global-set-key (kbd "<C-up>") 'backward-paragraph)
  (global-set-key (kbd "<C-down>") 'forward-paragraph)
  ;; (global-set-key (kbd "<s-S-up>") 'scroll-up-line)
  ;; (global-set-key (kbd "<s-S-down>") 'scroll-down-line)
#+END_SRC
** Backup
#+BEGIN_SRC emacs-lisp
; Backup and auto-save.
(setq
  backup-by-copying t      ; don't clobber symlinks
  backup-directory-alist
   '(("." . "~/.saves"))    ; don't litter my fs tree
  delete-old-versions t
  kept-new-versions 6
  kept-old-versions 2
  version-control t)       ; use versioned backups

(setq backup-directory-alist
          `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t)))
#+END_SRC
** History
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
* Shell
** Launch
#+BEGIN_SRC emacs-lisp
;; Shortcut to launch a shell
(global-set-key (kbd "C-x C-m") 'shell)

;; Open an eshell.
(global-set-key (kbd "<f12>") 'eshell)
#+END_SRC
* Treemacs
Requires Emacs 25.2+...
Replace EXAMPLE with SRC emacs-lisp to enable.
#+BEGIN_EXAMPLE
;; treemacs set up
(use-package treemacs
  :pin melpa-stable
  :ensure t)

(use-package treemacs-projectile
  :pin melpa-stable
  :ensure t)

(global-set-key (kbd "s-f p") 'treemacs-projectile) ;; works if current buffer is a projectile buffer; shows contents of parent folders as well
(global-set-key (kbd "s-f c") 'treemacs) ;; shows files and folders in current folder only
;;(global-set-key [fx] 'treemacs-projectile-toggle) ;; not using this - let treemacs-toggle do the job
(global-set-key (kbd "s-f t") 'treemacs-toggle)

(treemacs-follow-mode t)
(treemacs-filewatch-mode t)

(setq treemacs-follow-after-init          t
      treemacs-width                      35
      treemacs-indentation                2
      treemacs-git-integration            t
      treemacs-collapse-dirs              3
      treemacs-silent-refresh             nil
      treemacs-change-root-without-asking nil
      treemacs-sorting                    'alphabetic-desc
      treemacs-show-hidden-files          t
      treemacs-never-persist              nil
      treemacs-is-never-other-window      nil
      treemacs-goto-tag-strategy          'refetch-index
      treemacs-no-png-images              t)

   ;;(describe-variable 'treemacs-show-hidden-files)

;; temporary fix for missing icon issue in treemacs
(setq treemacs--not-selected-icon-background "gray8"
      treemacs--selected-icon-background     "darkolivegreen")
(--each treemacs--icons
  (progn
    (treemacs--set-img-property
     (get-text-property 0 'img-selected it)
     :background treemacs--selected-icon-background)
    (treemacs--set-img-property
     (get-text-property 0 'img-unselected it)
     :background treemacs--not-selected-icon-background)))

;; do without images
;; track treemacs issue #53 - this isn't ready yet
;; (setq treemacs-no-images t)
#+END_EXAMPLE
* E-mail/usenet clients
** TODO gnus
:PROPERTIES:
:CUSTOM_ID: sec:gnus
:END:
See: [[https://protesilaos.com/dotemacs/][protesilaos.com/dotemacs/]] for an example configuration.
#+BEGIN_SRC emacs-lisp

#+END_SRC
** TODO Notmuch (emacs email client)
Check configuration with [[#sec:gnus]] above.
#+BEGIN_SRC emacs-lisp
(use-package notmuch
    :ensure t)

(setq notmuch-poll-script "notmuch-poll")

;; notmuch-hello-mode-map
;; notmuch-search-mode-map
;; notmuch-show-mode-map

;; The delete tag (toggles deleted tag); to actually delete use
;; e.g. the following command: notmuch search --output=files
;; tag:deleted | xargs -l rm (setq debug-on-error t) ;;TODO
(define-key notmuch-search-mode-map "d"
      (lambda ()
        "toggle deleted tag for message"
        (interactive)
        (if (member "deleted" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-deleted"))
          (notmuch-show-tag (list "+deleted")))))

(define-key notmuch-show-mode-map "d"
      (lambda ()
        "toggle deleted tag for message"
        (interactive)
        (if (member "deleted" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-deleted"))
          (notmuch-show-tag (list "+deleted")))))

;; The spam tag (toggles spam tag)
(define-key notmuch-search-mode-map "S"
      (lambda ()
        "toggle spam tag for message"
        (interactive)
        (if (member "spam" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-spam"))
          (notmuch-show-tag (list "+spam")))))

(define-key notmuch-show-mode-map "S"
      (lambda ()
        "toggle spam tag for message"
        (interactive)
        (if (member "spam" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-spam"))
          (notmuch-show-tag (list "+spam")))))
#+END_SRC
* TODO Ignore-errors configuration
Is this ignore-errors construct necessary?
#+BEGIN_SRC emacs-lisp
;; These can produce errors when not in GUI mode (i.e. emacs --daemon).
(ignore-errors
  ;; Makes scrolling less jumpy.
  (setq scroll-margin 1
        scroll-conservatively 0
        scroll-up-aggressively 0.01
        scroll-down-aggressively 0.01)
  (setq-default scroll-up-aggressively 0.01
                scroll-down-aggressively 0.01)

  ;; scroll one line at a time (less "jumpy" than defaults)
  ;;  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
  (setq scroll-step 1) ;; keyboard scroll one line at a time

  ;; TODO Check and verify
  (setq scroll-step 1)
  (setq scroll-conservatively 10000)
  (setq auto-window-vscroll nil)
)
#+END_SRC
