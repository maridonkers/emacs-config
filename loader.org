#+TITLE: Emacs configuration using org-mode
#+STARTUP: indent
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamps:t
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing

* Introduction
GNU Emacs org-mode configuration file. Based on Arjen Wiersma's
[[https://gitlab.com/buildfunthings/emacs-config][emacs-config]], Sacha Chua's [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs configuration]], Daniel Mai's [[https://github.com/danielmai/.emacs.d][Mai
Emacs Configuration]] and [[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org][Uncle Dave's Emacs]]. Plus various snippets from the internet.

You can find the latest version of this configuration at
[[https://github.com/maridonkers/emacs-config]].

Disclaimer: tested only (my configuration) on Linux, with emacs 25.1.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Mari Donkers")

(defvar user-emacs-cache-directory
  (concat (getenv "HOME") "/.cache/emacs"))
#+END_SRC
* init.el
The org-mode tangling must be kicked of from =init.el=, via e.g. the following construct:

=init.el=:
#+BEGIN_EXAMPLE
(require 'org)
(require 'ob-tangle)

(setq init-dir (file-name-directory (or load-file-name (buffer-file-name))))
(org-babel-load-file (expand-file-name "loader.org" init-dir))
#+END_EXAMPLE
* Installing use-package
** Setup
GNU Emacs has a lot of packages that make things very easy for the
user. The package management infrastructure makes it a breeze to
install new packages and keep up-to-date with their development.

There are several package archives available for GNU Emacs:

- GNU
- Marmalade
- Melpa
- JCS Elpa ([[https://github.com/jcs-emacs/jcs-elpa#-how-to-use][jcs-emacs/jcs-elpa#-how-to-use]])

Each archive will write its files in a seperate archive directory.

#+BEGIN_SRC emacs-lisp
;; https://emacs.stackexchange.com/questions/71335/how-to-prevent-emacs-28-from-native-compiling-everything
(setq comp-deferred-compilation nil)
(require 'package)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar gnu '("gnu" . "http://elpa.gnu.org/packages/"))
(defvar melpa '("melpa" . "http://melpa.org/packages/"))
(defvar melpa-stable '("melpa-stable" . "http://stable.melpa.org/packages/"))
(defvar jcs-elpa '( "jcs-elpa" . "https://jcs-emacs.github.io/jcs-elpa/packages/"))

;; Add repositories (resetting defaults first).
(setq package-archives nil)
(add-to-list 'package-archives melpa-stable t)
(add-to-list 'package-archives melpa t)
(add-to-list 'package-archives gnu t)
(add-to-list 'package-archives jcs-elpa t)
#+END_SRC

Initialize the archive and refresh the contents in case there is no cached archive.

#+BEGIN_SRC emacs-lisp
  ;; (package-initialize)

  (unless (and (file-exists-p (concat init-dir "elpa/archives/gnu"))
               (file-exists-p (concat init-dir "elpa/archives/melpa"))
               (file-exists-p (concat init-dir "elpa/archives/melpa-stable")))
          (package-refresh-contents))
#+END_SRC

At each load the package list will be evaluated and any missing
packages will be installed. The packages-install function deals with
this check and takes care of any loading of the packages.

#+BEGIN_SRC emacs-lisp
(defun packages-install (&rest packages)
  (message "running packages-install")
    (mapc (lambda (package)
            (let ((name (car package))
                  (repo (cdr package)))
              (when (not (package-installed-p name))
                (let ((package-archives (list repo)))
                  (package-initialize)
                  (package-install name)))))
          packages)
    (package-initialize)
    (delete-other-windows))
#+END_SRC
** The package
#+BEGIN_SRC emacs-lisp
;; Install extensions if they're missing
(defun init--install-packages ()
  (message "Lets install some packages")
  (packages-install
   ;; Since use-package this is the only entry here
   ;; ALWAYS try to use use-package!
   (cons 'use-package melpa)))

(condition-case nil
  (init--install-packages)
  (error (package-refresh-contents)
         (init--install-packages)))
#+END_SRC
** Additionals for use-package
Because use-package supports :diminish and :delight.
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t)
(use-package delight
  :ensure t)
#+END_SRC
* Emacs
** Initialization
- Turn off mouse interface early in startup to avoid momentary display.
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
** Configuration
*** Visit quickly
#+BEGIN_SRC emacs-lisp
(defun config-visit ()
  "Visits ~/.emacs.d/loader.org"
  (interactive)
  (find-file "~/.emacs.d/loader.org"))
(global-set-key (kbd "s-c v") 'config-visit)
#+END_SRC
*** Reload
#+BEGIN_SRC emacs-lisp
(defun config-reload ()
  "Reloads ~/.emacs.d/loader.org at runtime"
  (interactive)
  (org-babel-load-file (expand-file-name "~/.emacs.d/loader.org")))
(global-set-key (kbd "s-c r") 'config-reload)
#+END_SRC
*** Delete frame
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x <C-backspace>") 'delete-frame)
#+END_SRC
*** Kill Emacs
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c <C-backspace>") 'kill-emacs)
#+END_SRC
*** buffer name
#+BEGIN_SRC emacs-lisp
(defun insert-buffer-name-at-point ()
  "Insert the name of the buffer at point."
  (interactive)
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point))
      (insert (concat (buffer-name) "\n")))))

(global-set-key (kbd "C-c @") 'insert-buffer-name-at-point)
#+END_SRC
*** pwd
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-?") 'pwd)
#+END_SRC
*** Lockfiles
Don't want them.
#+BEGIN_SRC emacs-lisp
(setq create-lockfiles nil)
#+END_SRC
*** Windows
Delete other windows.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-'") 'delete-other-windows)
  (global-set-key (kbd "C-\"") 'delete-window)
#+END_SRC
*** TODO Mode switching
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c m c") 'css-mode)
  ;; (global-set-key (kbd "C-c m f") 'flycheck-mode)
  (global-set-key (kbd "C-c m f") 'flymake-mode)
  (global-set-key (kbd "C-c m h") 'html-mode)
  (global-set-key (kbd "C-c m j") 'js-mode)
  (global-set-key (kbd "C-c m H") 'haskell-mode)
  (global-set-key (kbd "C-c m w") 'web-mode)
#+END_SRC
** Menu bar switch
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c h") 'menu-bar-mode)
#+END_SRC
** Cursor
*** TODO Set cursor color explicitly
(?) TODO: investigate why this is required
(the cursor doesn't have the correct color otherwise, for
emacsclient).
#+BEGIN_SRC emacs-lisp
(require 'frame)
(defun set-cursor-hook (frame)
  (modify-frame-parameters frame
                           (list (cons 'cursor-color "#ffff00"))))

(add-hook 'after-make-frame-functions 'set-cursor-hook)
#+END_SRC
*** Multiple cursors
The package [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]].
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :diminish multiple-cursors-mode
  :config (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
          (global-set-key (kbd "C-S-SPC") 'mc/edit-lines)
          (global-set-key (kbd "C->") 'mc/mark-next-like-this)
          (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
          (global-set-key (kbd "C-M-S-SPC") 'mc/mark-all-like-this))
#+END_SRC
*** Beacon
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :diminish beacon-mode
  :config
    (beacon-mode 1))
#+END_SRC
** TODO Prerequisite packages
  #+BEGIN_SRC emacs-lisp
    ;; (require 'cl)
    (setq byte-compile-warnings '(cl-functions))
  #+END_SRC
** Look and feel
*** Theme
#+BEGIN_SRC emacs-lisp
(use-package cyberpunk-theme
  :ensure t)

(load-theme 'cyberpunk t)

;; Selection color.
;;(set-face-background 'hl-line "#3e4446")
;; (set-face-foreground 'highlight nil)

;; Font size
(define-key global-map (kbd "C-c w +") 'text-scale-increase)
(define-key global-map (kbd "C-c w -") 'text-scale-decrease)

;; Clearer active window bar.
(set-face-attribute  'mode-line-inactive
                    nil
                    :foreground "white"
                    :background "#232323"
                    ;; :box '(:line-width 1 :style released-button)
                    :box nil)

(set-face-attribute  'mode-line
                    nil
                    :foreground "black"
                    :background "darkcyan"
                    ;; :box '(:line-width 1 :style released-button)
                    :box nil)

;; No boxes around mode line (cyberpunk theme creates these).
(set-face-attribute `mode-line nil :box nil)
(set-face-attribute `mode-line-inactive nil :box nil)

;; Set cursor color, shape and no blinking.
(setq-default cursor-color "#ffff00")
(set-cursor-color "#ffff00")
;;(setq-default cursor-type 'hollow)
(blink-cursor-mode 0)

;; To accommodate aging eyes and code.
(define-key global-map (kbd "C-c C-!") (lambda () (interactive)
                                         (set-face-attribute 'default nil :height 140 :font "Hack")))
;; Also set at initialization, as a default.
(add-hook 'after-init-hook
          #'(lambda ()
              (custom-set-faces
                '(default ((t (:height 140 :font "Hack")))))))
#+END_SRC
*** Sane defaults
[[https://github.com/danielmai/.emacs.d/blob/master/config.org]].
#+BEGIN_SRC emacs-lisp
  ;; These functions are useful. Activate them.
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)

  ;; Answering just 'y' or 'n' will do
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; UTF-8 please
  (setq locale-coding-system 'utf-8) ; pretty
  (set-terminal-coding-system 'utf-8) ; pretty
  (set-keyboard-coding-system 'utf-8) ; pretty
  (set-selection-coding-system 'utf-8) ; please
  (prefer-coding-system 'utf-8) ; with sugar on top
  (setq-default indent-tabs-mode nil)

  (setq-default indent-tabs-mode nil)
  (setq-default indicate-empty-lines t)

  ;; Don't count two spaces after a period as the end of a sentence.
  ;; Just one space is needed.
  (setq sentence-end-double-space nil)

  ;; delete the region when typing, just like as we expect nowadays.
  (delete-selection-mode t)

  (show-paren-mode t)

  (column-number-mode t)

  ;; Beware of text wrapping in the middle of a word
  (global-visual-line-mode 1)
  (global-set-key (kbd "C-x x v") 'visual-line-mode)

  ;; In whitespace-mode whitespaces are shown visibly
  (global-set-key (kbd "C-x x w") 'whitespace-mode)

  ;; Soft wrap at window edge behaviour for text buffers.
  (setq line-move-visual nil)
  (add-hook 'text-mode-hook 'toggle-truncate-lines)

  ;TODO CHECK ERROR: symbol's function definition is void: diminish
  ;(diminish 'visual-line-mode)

  ;; https://gist.github.com/leemeichin/4032852
  ;; http://www.raebear.net/computers/emacs-colors/
  ;; Sets the default mode-line. Remove '-default' if you want to test your changes on-the-fly with (eval-buffer)
  (setq-default mode-line-format
      '(
        ;; show the buffer filename
        (:eval
         (propertize
                     (if (buffer-modified-p)
                       " ** %b "
                       (if (eql buffer-read-only t)
                           " == %b "
                           " -- %b "))))
        ;; show the current major mode in use (use obsolete format because trailing spaces nice it up)
        (:propertize " %m ")
        ;; show the current branch and VCS in use, if there is one
        (:propertize (vc-mode vc-mode) face (:weight normal))
        " "
        ;; show the line number and column number (no 'All', 'Top', 'Bottom', etc.)
        (:propertize " %l:%c ")
        ;; Show full path.
        (:eval
           (propertize " %f "))
        ))

  ;; (setq-default frame-title-format "%b (%f)")
  ;; (setq-default mode-line-format "%b (%f)")

  ;; (setq uniquify-buffer-name-style 'forward)
  ;; (setq uniquify-buffer-name-style 'reverse)

  ;; Turn off emacs alarms (those annoying beeps)
  (setq ring-bell-function 'ignore)
  (setq visible-bell t)
#+END_SRC
*** Title
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      (list (format "%s %%S: %%j " (system-name))
        '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))
#+END_SRC
*** Desktop
Also check this out: [[https://emacs.stackexchange.com/questions/31621/handle-stale-desktop-lock-files-after-emacs-system-crash][Handle stale desktop lock files after emacs/system crash]]
#+BEGIN_SRC emacs-lisp
;; Store desktop (i.e. open files, etc.) at exit (restores when starting again).
(setq desktop-path '("."))
(desktop-save-mode 1)
(global-set-key (kbd "C-c C-d") 'desktop-save)
#+END_SRC
*** Ignore error wrapping
#+BEGIN_SRC emacs-lisp
;(defun ignore-error-wrapper (fn)
;  "Funtion return new function that ignore errors.
;   The function wraps a function with `ignore-errors' macro."
;  (lexical-let ((fn fn))
;    (lambda ()
;      (interactive)
;      (ignore-errors
;        (funcall fn)))))
#+END_SRC
*** sidebar (dired)
#+BEGIN_SRC emacs-lisp
(use-package dired-sidebar
  :pin melpa-stable
  :ensure t
  :commands (dired-sidebar-toggle-sidebar)
  :bind (("C-c b" . (lambda () (interactive)
                        (dired-sidebar-show-sidebar)
                        (next-window-any-frame)))))
#+END_SRC
*** Moving around
**** Bookmarks
#+BEGIN_SRC emacs-lisp
;; Disable auto save
(setq bookmark-save-flag nil)

;; Visuals for bookmarks.
(defun my/add-bookmark-visual-indicator ()
  (let ((bm-overlay (make-overlay (line-beginning-position) (line-end-position))))
    (overlay-put bm-overlay 'face '(:background "#36a126" :foreground "black"))
    (overlay-put bm-overlay 'my-bookmark-overlay t)))

(defun my/remove-bookmark-visual-indicators ()
  (remove-overlays (point-min) (point-max) 'my-bookmark-overlay t))

(defun my/bookmark-set-hook (&rest _args)
  "Function to be called after a bookmark is set."
  (my/add-bookmark-visual-indicator))

(defun my/global-refresh-bookmark-visual-indicators ()
  "Globally refresh visual indicators for all bookmarks across all buffers."
  (dolist (buf (buffer-list))
    (with-current-buffer buf
      (when (buffer-file-name) ; Only operate on buffers associated with files
        (my/refresh-bookmark-visual-indicators-for-current-buffer)))))

(defun my/refresh-bookmark-visual-indicators-for-current-buffer ()
  "Refresh visual indicators for all bookmarks in the current buffer."
  (my/remove-bookmark-visual-indicators) ; Assume this is already buffer-local in its operation
  ;; Loop through all bookmarks and apply indicators if they belong to the current buffer.
  (let ((current-file (buffer-file-name)))
    (dolist (bookmark (bookmark-all-names))
      (let ((bookmark-filename (bookmark-get-filename bookmark))
            (pos (bookmark-get-position bookmark)))
        (when (and bookmark-filename
                   current-file
                   pos
                   (file-equal-p bookmark-filename current-file))
          (save-excursion
            (goto-char pos)
            (my/add-bookmark-visual-indicator)))))))

(defun my/bookmark-delete-hook (&rest _args)
  "Function to be called after a bookmark is deleted."
  (my/global-refresh-bookmark-visual-indicators))

;; Hack To ensure that bookmarks get initialized.
(defun my/bookmark-refresh (&rest _args)
  "Function to be refresh bookmarks visual indicators."
  (interactive)
  (bookmark-bmenu-list)
  (kill-buffer "*Bookmark List*")  
  (my/global-refresh-bookmark-visual-indicators))

;; This is a hack but appears to work.
(defun my/run-bookmark-refresh ()
  "Run bookmark refresh function after Emacs has finished loading the buffer."
  (run-with-idle-timer 0 nil #'my/bookmark-refresh))

(add-hook 'find-file-hook #'my/run-bookmark-refresh)
(add-hook 'desktop-after-read-hook #'my/run-bookmark-refresh)

(advice-add 'bookmark-set :after #'my/bookmark-set-hook)
(advice-add 'bookmark-delete :after #'my/bookmark-delete-hook)
(add-hook 'bookmark-after-jump-hook 'my/add-bookmark-visual-indicator)

(global-set-key (kbd "C-x r D") 'bookmark-delete)
(global-set-key (kbd "C-x r L") 'bookmark-load)
(global-set-key (kbd "C-x r S") 'bookmark-save)
(global-set-key (kbd "C-x r R") 'my/bookmark-refresh)

(global-set-key (kbd "C-x r p d") 'bookmark-delete-all)
(global-set-key (kbd "C-x r p l") (lambda () "Load project bookmarks" (interactive) (bookmark-load (expand-file-name ".emacs.bookmarks" command-line-default-directory))))
(global-set-key (kbd "C-x r p s") (lambda () "Save project bookmarks" (interactive) (bookmark-write-file (expand-file-name ".emacs.bookmarks" command-line-default-directory))))
#+END_SRC
**** Bookmarks (bm)
Bookmarks are very useful for quickly jumping around files.
#+BEGIN_SRC emacs-lisp
(use-package bm
  :ensure t
  :bind (("<M-S-SPC>" . bm-toggle)
         ("M-S-<backspace>" . bm-remove-all-current-buffer)
         ("M-L" . bm-show-all)
         ("M-S-<prior>" . bm-previous)
         ("M-S-<next>" . bm-next)))
#+END_SRC
*** Winner mode
#+BEGIN_SRC emacs-lisp
;; Winner mode
;; From: http://www.emacswiki.org/emacs/WinnerMode
(when (fboundp 'winner-mode)
  (winner-mode 1))
#+END_SRC
*** Window swapping
From [[https://www.emacswiki.org/emacs/TransposeWindows][Transpose Windows]].
#+BEGIN_SRC emacs-lisp
;; Initialization of these variables is required.
(setq swapping-buffer nil)
(setq swapping-window nil)

;; First call marks window and after switch to second window call
;; again to swap the windows.
(defun swap-buffers-in-windows ()
   "Swap buffers between two windows"
   (interactive)
   (if (and swapping-window
            swapping-buffer)
       (let ((this-buffer (current-buffer))
             (this-window (selected-window)))
         (if (and (window-live-p swapping-window)
                  (buffer-live-p swapping-buffer))
             (progn (switch-to-buffer swapping-buffer)
                    (select-window swapping-window)
                    (switch-to-buffer this-buffer)
                    (select-window this-window)
                    (message "Swapped buffers."))
           (message "Old buffer/window killed.  Aborting."))
         (setq swapping-buffer nil)
         (setq swapping-window nil))
     (progn
       (setq swapping-buffer (current-buffer))
       (setq swapping-window (selected-window))
       (message "Buffer and window marked for swapping."))))

;; Switch windows.
;;(global-set-key (kbd "C-c C-w") 'transpose-windows)
(global-set-key (kbd "C-c C-w") 'swap-buffers-in-windows)

(global-set-key [f9] 'other-window)
#+END_SRC
*** Window moving
#+BEGIN_SRC emacs-lisp
  ;; Windmove configuration.
;  (global-set-key (kbd "C-c <C-left>") (ignore-error-wrapper 'windmove-left))
;  (global-set-key (kbd "C-c <C-right>") (ignore-error-wrapper 'windmove-right))
;  (global-set-key (kbd "C-c <C-up>") (ignore-error-wrapper 'windmove-up))
;  (global-set-key (kbd "C-c <C-down>") (ignore-error-wrapper 'windmove-down))

  (global-set-key (kbd "C-c <C-left>") 'windmove-left)
  (global-set-key (kbd "C-<kp-4>") 'windmove-left)
  (global-set-key (kbd "C-c <C-right>") 'windmove-right)
  (global-set-key (kbd "C-<kp-6>") 'windmove-right)
  (global-set-key (kbd "C-c <C-up>") 'windmove-up)
  (global-set-key (kbd "C-<kp-8>") 'windmove-up)
  (global-set-key (kbd "C-c <C-down>") 'windmove-down)
  (global-set-key (kbd "C-<kp-2>") 'windmove-down)
#+END_SRC
*** Frame toggle full screen
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-s-SPC>") 'toggle-frame-fullscreen)
#+END_SRC
*** Window minimize/maximize
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c -") 'minimize-window)
(global-set-key (kbd "C-c +") 'maximize-window)
#+END_SRC
*** Window resizing
#+BEGIN_SRC emacs-lisp
(defun shrink-window-horizontally-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (shrink-window-horizontally 10))

(defun enlarge-window-horizontally-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (enlarge-window-horizontally 10))

(defun shrink-window-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (shrink-window 10))

(defun enlarge-window-stepped (&optional arg)
  (interactive "P")
  (if (one-window-p) (error "Cannot resize sole window"))
  (enlarge-window 10))

;; Window resize bindings.
(global-set-key (kbd "C-S-x <C-S-left>") 'shrink-window-horizontally-stepped)
(global-set-key (kbd "C-S-x <C-S-right>") 'enlarge-window-horizontally-stepped)
(global-set-key (kbd "C-S-x <C-S-down>") 'shrink-window-stepped)
(global-set-key (kbd "C-S-x <C-S-up>") 'enlarge-window-stepped)

(global-set-key (kbd "C-S-c <C-S-left>") 'shrink-window-horizontally)
(global-set-key (kbd "C-S-c <C-S-right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-S-c <C-S-down>") 'shrink-window)
(global-set-key (kbd "C-S-c <C-S-up>") 'enlarge-window)
#+END_SRC
*** Minibuffer
#+BEGIN_SRC emacs-lisp
(defun switch-to-minibuffer ()
  "Switch to minibuffer window."
  (interactive)
  (if (active-minibuffer-window)
      (select-window (active-minibuffer-window))
    (error "Minibuffer is not active")))

;; Switch to minibuffer.
(global-set-key (kbd "C-x M") 'switch-to-minibuffer)
#+END_SRC
*** Ivy, Counsel
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :diminish ivy-mode
  :config (global-set-key (kbd "C-x b") 'ivy-switch-buffer)
          (global-set-key (kbd "C-c C-r") 'ivy-resume)
          (global-set-key (kbd "<f6>") 'ivy-resume))

(use-package counsel
  :ensure t
  :diminish counsel-mode
  :config (global-set-key (kbd "M-x") 'counsel-M-x)
          (global-set-key (kbd "C-x C-f") 'counsel-find-file)
          (global-set-key (kbd "C-x C-S-r") 'counsel-recentf)
          (global-set-key (kbd "<f1> f") 'counsel-describe-function)
          (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
          (global-set-key (kbd "<f1> l") 'counsel-load-library)
          (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
          (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
          (global-set-key (kbd "C-c g") 'counsel-git)
          (global-set-key (kbd "C-c j") 'counsel-git-grep)
          (global-set-key (kbd "C-c a") 'counsel-ag)
          (global-set-key (kbd "C-c l") 'counsel-locate)
          (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
          (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
          )

(use-package counsel-projectile
  :ensure t
  :diminish counsel-projectile-mode
  :config (counsel-projectile-mode))
#+END_SRC
*** Mark
**** Selection
#+BEGIN_SRC emacs-lisp
(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(defun jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))

;; Mark without select visible.
(global-set-key (kbd "C-`") 'push-mark-no-activate)
(global-set-key (kbd "C-~") 'jump-to-mark)
#+END_SRC
**** Convenience mapping for navigating back to your previous editing spots
#+BEGIN_SRC emacs-lisp
  ;; Does C-U C-SPC programatically.
  (defun set-mark-command-prefix-arg ()
    (interactive)
    (setq current-prefix-arg '(4)) ; C-u
    (call-interactively 'set-mark-command))

  (global-set-key (kbd "M-]") 'counsel-mark-ring)
  (global-set-key (kbd "M-[") 'set-mark-command-prefix-arg)
#+END_SRC
*** Tabs
#+BEGIN_SRC emacs-lisp
;; Tab indentation width.
(setq tab-width 4)
#+END_SRC
*** Speedbar
#+BEGIN_SRC emacs-lisp
(global-set-key [f11] 'speedbar)
#+END_SRC
*** Internet Browser
**** org-mode copy ndk/link-fast-copy
See [[https://emacs.stackexchange.com/questions/63037/fast-way-to-copy-a-link-at-point-in-org-mode]]
#+BEGIN_SRC emacs-lisp
(defun ndk/link-fast-copy ()
   (interactive)
   (let* ((context (org-element-context))
          (type (org-element-type context))
          (beg (org-element-property :begin context))
          (end (org-element-property :end context)))
     (when (eq type 'link)
      (copy-region-as-kill beg end))))

(define-key org-mode-map (kbd "C-c z") #'ndk/link-fast-copy)
#+END_SRC
Alternatively check out: [[https://hungyi.net/posts/copy-org-mode-url/]]
**** TODO eww
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'eww-browse-url)
#+END_SRC
#+END_EXAMPLE
**** Librewolf
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "librewolf"
      browse-url-generic-args '("--new-window"))
#+END_SRC
**** TODO Nyxt
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "nyxt"
      ;; browse-url-generic-args '("-new-window")
      )
#+END_SRC
#+END_EXAMPLE
**** Brave
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "brave"
      browse-url-generic-args '("--new-window"))
#+END_SRC
#+END_EXAMPLE
**** TODO Firefox
You can set Firefox to open all external links in the same tab.

 - Enter about:config in the address bar.
 - Click the confirmation button if shown.
 - Filter for browser.link.open_newwindow.
 - Double click.
 - Set value to 1.
 - OK.
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
  ;; (setq browse-url-browser-function 'browse-url-generic
  ;;       browse-url-generic-program "xdg-open")

(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "firefox"
      browse-url-generic-args '("-new-window"))

  ;; (setq browse-url-browser-function 'browse-url-generic
  ;;       browse-url-generic-program "xdg-open")

  ;; (setq browse-url-browser-function 'browse-url-chromium
  ;;       browse-url-generic-program "chromium")
  ;; (defun browse-url-chromium (url &optional new-window)
  ;;  "Open URL in a new Chromium window."
  ;;  (interactive (browse-url-interactive-arg "URL: "))
  ;;  (unless
  ;;      (string= ""
  ;;               (shell-command-to-string
  ;;                (concat "chromium " url)))
  ;;    (message "Starting Chromium...")
  ;;    (start-process (concat "chromium " url) nil "chromium " url)
  ;;    (message "Starting Chromium... done")))
#+END_SRC
#+END_EXAMPLE
** Break & Debug
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-M-g") 'top-level)
; (toggle-debug-on-quit)
#+END_SRC
** Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC
** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
#+END_SRC
** Revert buffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-M-f") 'revert-buffer)
#+END_SRC
** Large files
#+BEGIN_SRC emacs-lisp
  ;; Large files slow emacs down to a grind. Main offender is fundamental mode.
  (defun my-find-file-check-make-large-file-read-only-hook ()
    "If a file is over a given size, make the buffer read only."
    (when (> (buffer-size) (* 1024 1024))
      ;;(setq buffer-read-only t)
      ;;(buffer-disable-undo)
      (fundamental-mode)))

  (add-hook 'find-file-hook 'my-find-file-check-make-large-file-read-only-hook)

  (global-set-key (kbd "M-o") 'read-only-mode)
#+END_SRC
** Disable auto save and -backup
#+BEGIN_SRC emacs-lisp
;disable backup
(setq backup-inhibited t)
;disable auto save
(setq auto-save-default nil)
#+END_SRC
** sudo-edit
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
  :ensure t
  :bind
    ("C-M-e" . sudo-edit))
#+END_SRC
** async
#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :init (dired-async-mode 1))
#+END_SRC
** dmenu
#+BEGIN_SRC emacs-lisp
(use-package dmenu
  :ensure t)
(global-set-key (kbd "C-c d") 'dmenu)
#+END_SRC
** Follow created window
[[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org]]
#+BEGIN_SRC emacs-lisp
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC
** Swiper
Retrying Swiper (is it now faster with big files?)
#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind ("C-=" . 'swiper))
#+END_SRC
** ibuffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
;; (setq ibuffer-expert t)
#+END_SRC
** Kill current buffer
https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org
#+BEGIN_SRC emacs-lisp
(defun kill-current-buffer ()
  "Kills the current buffer."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC
** Kill all buffers
https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org
#+BEGIN_SRC emacs-lisp
(defun close-all-buffers ()
  "Kill all buffers without regard for their origin."
  (interactive)
  (mapc 'kill-buffer (buffer-list)))
(global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC
** Kill ring
*** Size
#+BEGIN_SRC emacs-lisp
(setq kill-ring-max 100)
#+END_SRC
*** Clear
#+BEGIN_SRC emacs-lisp
(defun clear-kill-ring ()
  (interactive)
  (setq kill-ring nil)
  (garbage-collect))
(global-set-key (kbd "s-y") 'clear-kill-ring)
#+END_SRC
*** popup-kill-ring
#+BEGIN_SRC emacs-lisp
(use-package popup-kill-ring
  :ensure t
  :bind ("M-y" . popup-kill-ring))
#+END_SRC
** Bash
#+BEGIN_SRC emacs-lisp
(defvar my-term-shell "/bin/bash")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
(global-set-key (kbd "C-c t") 'ansi-term)
#+END_SRC
** Time
#+BEGIN_SRC emacs-lisp
(setq display-time-24hr-format t)
(setq display-time-format "%H:%M - %d %B %Y")
(display-time-mode 1)
#+END_SRC
* evil
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t)

;(require 'evil)
;(evil-mode 1)
(define-key projectile-mode-map (kbd "M-+") 'evil-mode)
#+END_SRC
#+END_EXAMPLE
* Org-mode
Org-mode is an Emacs built-in.
** TODO Shortcuts
#+BEGIN_SRC emacs-lisp
;;TODO
;;(require 'org)
;;(define-key global-map "\C-cl" 'org-store-link)
;;(define-key global-map "\C-ca" 'org-agenda)
;;(setq org-log-done t)

(setq org-src-preserve-indentation t)
(define-key org-mode-map (kbd "<C-M-tab>") 'pcomplete)
(define-key org-mode-map (kbd "C-c o r +") 'org-table-insert-row)
(define-key org-mode-map (kbd "C-c o c +") 'org-table-insert-column)
(define-key org-mode-map (kbd "C-c o r -") 'org-table-kill-row)
(define-key org-mode-map (kbd "C-c o c -") 'org-table-delete-column)
#+END_SRC
** TODO org-bullets
Disabled this because it results in 100% CPU usage.
#+BEGIN_SRC emacs-lisp
;; (use-package org-bullets
;;   :ensure t
;;   :diminish org-bullets-mode
;;   :config
;;     (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC
** Exports
#+BEGIN_SRC emacs-lisp
(use-package ox-twbs
  :ensure t)
#+END_SRC
** Indentation
#+BEGIN_SRC emacs-lisp
;TODO CHECK ERROR: symbol's function definition is void: diminish
;(eval-after-load "org-indent" '(diminish 'org-indent-mode))
#+END_SRC
** HTMLize buffers
When exporting documents to HTML documents, such as code fragments, we need to htmlize.
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t)
#+END_SRC
** TODO Reveal.js
Tool to create presentations via an emacs org file export. See: [[https://github.com/emacsmirror/org-re-reveal]].
Replace EXAMPLE with SRC emacs-lisp to enable.
#+BEGIN_EXAMPLE
;;TODO doesn't appear to work (breaks org-mode export of title sections).
(use-package org-re-reveal
  :ensure t)

;; Reveal.js location and ox-reveal.
;;(setq org-reveal-root "file:///home/mdo/lib/reveal.js")
;;(setq org-reveal-mathjax t)
#+END_EXAMPLE
* Comma Separated Files
#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :ensure t)
#+END_SRC
* Mediawiki
MediaWiki mode.
#+BEGIN_SRC emacs-lisp
(use-package mediawiki
  :ensure t)
#+END_SRC
* Edit indirect
The edit-indirect package is used by Markdown for editing code blocks.
#+BEGIN_SRC emacs-lisp
(use-package edit-indirect
  :ensure t)
#+END_SRC
* Markdown
Markdown is a great way to write documentation, not as good as
=org-mode= of course, but generally accepted as a standard.
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t)
#+END_SRC
* AsciiDoc
[[http://www.methods.co.nz/asciidoc/][AsciiDoc]] is an alternative way to write documentation, not as good as
=org-mode= of course, but supported by e.g. github. The [[https://github.com/sensorflo/adoc-mode/wiki][adoc-mode]] Emacs
major mode supports the adoc format.
#+BEGIN_SRC emacs-lisp
(use-package adoc-mode
  :ensure t)

(add-to-list 'auto-mode-alist (cons "\\.adoc\\'" 'adoc-mode))
(add-hook 'adoc-mode-hook (lambda() (buffer-face-mode t)))
#+END_SRC
* LaTex
This installs the [[https://www.gnu.org/software/auctex/][auctex]] and [[https://github.com/tom-tan/auctex-latexmk][auctex-latexmk]] packages.
#+BEGIN_SRC emacs-lisp
(use-package tex
    :ensure auctex
    :config (setq TeX-auto-save t)
            (setq TeX-parse-self t)
            (setq TeX-save-query nil)
            (setq latex-run-command "pdflatex"))
;;(setq TeX-PDF-mode t)
(require 'tex)

(use-package auctex-latexmk
    :ensure auctex-latexmk)
(require 'auctex-latexmk)
(auctex-latexmk-setup)
(setq auctex-latexmk-inherit-TeX-PDF-mode t)
;; PDF viewer options
(setq TeX-view-program-list '(("Zathura" "zathura --page=%(outpage) %o")))
(setq TeX-view-program-selection '((output-pdf "Zathura")))
#+END_SRC
* Programming
** General
Setup for GNU Emacs, software development. Plus [[https://github.com/Fuco1/smartparens][Smartparens]].

The structured editing of smartparens is useful in a LOT of languages, as
long as there are parenthesis, brackets or quotes.
*** Utilities
String manipulation routines for emacs lisp
#+BEGIN_SRC emacs-lisp
(use-package s
  :ensure t)
#+END_SRC
*** Smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config (progn (show-smartparens-global-mode t))
                 (add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)
                 (add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-strict-mode)
                 (add-hook 'ielm-mode-hook #'smartparens-strict-mode)
                 (add-hook 'lisp-mode-hook #'smartparens-strict-mode)
                 (add-hook 'lisp-interaction-mode-hook #'smartparens-strict-mode)
                 (add-hook 'scheme-mode-hook #'smartparens-strict-mode)
  :bind (("<f7>" . smartparens-strict-mode)
         ("C-S-s a" . sp-beginning-of-sexp)
         ("C-S-s e" . sp-end-of-sexp)
         ("C-S-s d" . sp-down-sexp)
         ("C-S-s u" . sp-up-sexp)
         ("C-S-s D" . sp-backward-down-sexp)
         ("C-S-s U" . sp-up-down-sexp)
         ("C-S-s f" . sp-forward-sexp)
         ("C-S-s b" . sp-backward-sexp)
         ("C-M-<right>" . sp-next-sexp)
         ("C-M-<left>" . sp-previous-sexp)
         ("C-S-s S" . sp-backward-symbol)
         ("C-S-s s" . sp-forward-symbol)
         ("C-S-s |" . sp-split-sexp)
         ("C-S-s U" . sp-backward-unwrap-sexp)
         ("C-S-s u" . sp-unwrap-sexp)
         ("M-<right>" . sp-forward-slurp-sexp)
         ("M-S-<right>" . sp-forward-barf-sexp)
         ("M-<left>" . sp-backward-slurp-sexp)
         ("M-S-<left>" . sp-backward-barf-sexp)
         ("C-S-s t" . sp-transpose-sexp)
         ("C-S-s k" . sp-kill-sexp)
         ("C-S-s h" . sp-kill-hybrid-sexp)
         ("C-S-s K" . sp-backward-kill-sexp)))
#+END_SRC
*** Highlight parentheses
#+BEGIN_SRC emacs-lisp
(use-package highlight-parentheses
  :ensure t
  :diminish highlight-parentheses-mode
  :config (add-hook 'emacs-lisp-mode-hook
            (lambda() (highlight-parentheses-mode))))

(global-highlight-parentheses-mode)
#+END_SRC
*** Rainbow
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  :diminish rainbow-mode
  :init
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC
*** Rainbow delimiters
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :diminish rainbow-delimiters-mode
  :config (add-hook 'lisp-mode-hook
              (lambda() (rainbow-delimiters-mode))))

(global-highlight-parentheses-mode)
#+END_SRC
*** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode
  :config (yas/global-mode 1)
          (add-to-list 'yas-snippet-dirs (concat init-dir "snippets"))
          (add-hook 'web-mode-hook #'(lambda () (yas-activate-extra-mode 'html-mode)))
          (add-hook 'web-mode-hook #'(lambda () (yas-activate-extra-mode 'css-mode))))
#+END_SRC
*** Auto completion
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  ;;:diminish company-mode
  :bind (("C-<tab>" . company-complete))
  :config (global-company-mode 1)
          (setq company-idle-delay 0.3)
          ;; (global-set-key (kbd "C-<tab>") 'company-complete)
)
#+END_SRC
*** Code folding
#+BEGIN_SRC emacs-lisp
(use-package origami
  :ensure t
  :diminish origami-mode
  :config (global-origami-mode)
  :bind (("C-c |" . origami-reset)
         ("C-c {" . origami-open-node-recursively)
         ("C-c }" . origami-close-node-recursively)
         ("C-c \"" . origami-toggle-all-nodes)))
#+END_SRC
*** Version Control
Magit is the only thing you need when it comes to Version Control (Git)

#+BEGIN_SRC emacs-lisp
(setq package-install-upgrade-built-in t)
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status)))
#+END_SRC

*** Projectile
#+BEGIN_SRC emacs-lisp
;; Project based navigation and search. Note also the .projectile file that
;; can be placed in the root of a project. It can be used to exclude (or include)
;; directories (see: https://github.com/bbatsov/projectile).
(use-package projectile
  :ensure t
  :diminish projectile-mode)

(projectile-mode +1)
(define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
#+END_SRC
*** REST (client) support
#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t)
#+END_SRC

*** TODO Imenu
Replace EXAMPLE with SRC emacs-lisp to enable.
#+BEGIN_EXAMPLE
;; Add imenu to menu bar and make it automatically rescan.
(setq imenu-auto-rescan 1)

;; Incremental imenu.
(global-set-key (kbd "C-S-l") 'imenu)
#+END_EXAMPLE
*** Symbols
**** TODO Highlight s-exp
#+BEGIN_SRC emacs-lisp
; (use-package hl-sexp
;   :ensure t
;   :config (add-hook 'lisp-mode-hook #'hl-sexp-mode)
;           (add-hook 'emacs-lisp-mode-hook #'hl-sexp-mode)
;   :bind (("C-M-'" . hl-sexp-mode)))
#+END_SRC
**** Highlight symbol
Global highlight code taken from [[https://github.com/nschum/highlight-symbol.el/issues/11]].
#+BEGIN_SRC emacs-lisp
(defun highlight-symbol-mode-on () (highlight-symbol-mode 1))
(define-globalized-minor-mode global-highlight-symbol-mode
                              highlight-symbol-mode
                              highlight-symbol-mode-on)

(use-package highlight-symbol
  :ensure t
  :diminish highlight-symbol-mode
  :config (setq highlight-symbol-idle-delay  0.5)
  :bind (("C-*" . highlight-symbol)
         ("M-*" . highlight-symbol-remove-all)
         ("<f8>" . highlight-symbol-next)
         ("S-<f8>" . highlight-symbol-prev)
         ("M-<f8>" . highlight-symbol-query-replace)))

;;WARNING: interferes with Magit faces. (do not use global mode).
;;(global-highlight-symbol-mode 1)
#+END_SRC
*** Dumb-jump
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t
  :diminish dumb-jump-mode
  :bind (("C-." . dumb-jump-go)
         ("C-," . dumb-jump-back)))
#+END_SRC
*** TODO hl-line
This interferes with search colors.
#+BEGIN_SRC emacs-lisp
;(when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC
** TODO Flycheck syntax checker
See here: [[https://www.flycheck.org/en/latest/user/installation.html][flycheck.org/installation]].

BTW: flycheck mode is not enabled by default because my computer is
too slow (with Haskell code) because every small change triggers
expensive checking. Instead I now enable it per project, via
=.dir-locals.el=. Also I initiate interactive Haskell mode via the
<C-S-return> and/or C-Z keybindings, which activates its functions
('hover over' type info in the minibuffer, C-c RET
haskell-process-do-info, etc). File loading is still somewhat slow but
when it's loaded and a C-c S-RET is done, it's very usable).

e.g. as follows:
#+BEGIN_EXAMPLE
((nil
  (custom-set-variables
 ;; Customization related to indentation.
    '(haskell-indentation-layout-offset 2)
    '(haskell-indentation-starter-offset 2)
    '(haskell-indentation-left-offset 2)
    '(haskell-indentation-where-pre-offset 2)
    '(haskell-indentation-where-post-offset 2)
  )
  (haskell-process-type . ghci)
  (format-all-formatters
   ("Haskell" ormolu)
   ("Literate Haskell" ormolu)
  )
  (eval . (flycheck-mode 0))
)) 
#+END_EXAMPLE

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :pin melpa-stable
    :ensure t
    ;; :init (global-flycheck-mode)
    :diminish flycheck-mode
    :bind (("C-C f" . flycheck-buffer)
           ("C-C >" . flycheck-next-error)
           ("C-C <" . flycheck-previous-error)
           ("C-C ?" . flycheck-list-errors)))

  ;; (add-hook 'prog-mode-hook #'flycheck-mode)
  (flycheck-mode 0)
#+END_SRC
#+END_EXAMPLE
** eldoc
The =eldoc-doc-buffer=
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c e") 'eldoc-doc-buffer)
#+END_SRC
** TODO PlantUML
See: [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-plantuml.html]].
#+BEGIN_SRC emacs-lisp
;; Not available error?
(use-package plantuml-mode
  :pin melpa-stable
  :ensure t)

;; (setq plantuml-jar-path "/run/current-system/sw/bin/plantuml")
;; (setq org-plantuml-jar-path "/run/current-system/sw/bin/plantuml")

(setq org-plantuml-exec-mode 'plantuml)
(setq org-plantuml-executable-path "/run/current-system/sw/bin/plantuml")
(setq org-plantuml-executable-args '("-headless" "-charset UTF-8"))
(setq org-confirm-babel-evaluate nil)

(org-babel-do-load-languages
  'org-babel-load-languages
  '((plantuml . t))) ; this line activates plantuml
#+END_SRC
** LSP
*** TODO lsp-mode
For =elixir-mode. To configure this for =rust-mode= see [[https://www.mortens.dev/blog/emacs-and-the-language-server-protocol/][mortens.dev/blog/emacs-and-the-language-server-protocol]]
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  ;; :pin melpa-stable
  :commands lsp
  :ensure t
  :diminish lsp-mode
    :hook
    (elixir-mode . lsp)
    :init
    (add-to-list 'exec-path "~/lib/elixir-ls")
  :custom
  ;; what to use when checking on-save. "check" is default, I prefer clippy
  (lsp-rust-analyzer-cargo-watch-command "clippy")
  (lsp-eldoc-render-all nil) ; t
  (lsp-idle-delay 0.6)
  ;; This controls the overlays that display type and other hints inline. Enable
  ;; / disable as you prefer. Well require a `lsp-workspace-restart' to have an
  ;; effect on open projects.
  (lsp-rust-analyzer-server-display-inlay-hints t)
  (lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial")
  (lsp-rust-analyzer-display-chaining-hints t)
  (lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil)
  (lsp-rust-analyzer-display-closure-return-type-hints t)
  (lsp-rust-analyzer-display-parameter-hints nil)
  (lsp-rust-analyzer-display-reborrow-hints nil)
  :config  
  ;; (setq lsp-prefer-flymake nil) ;; Prefer using lsp-ui (flycheck) over flymake.
  (add-hook 'rust-mode-hook 'lsp-deferred)
  (add-hook 'lsp-mode-hook 'lsp-ui-mode)
  (add-to-list 'auto-mode-alist '("\\.exs\\'" . elixir-mode))
)
#+END_SRC
#+END_EXAMPLE
*** lsp-ui
See: [[https://github.com/rksm/emacs-rust-config/blob/master/init.el][rksm/emacs-rust-config/blob/master/init.el]]
#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :ensure
  :commands lsp-ui-mode
  :bind (("M-j" . lsp-ui-imenu)
         ("M-?" . lsp-find-references)
         ("C-c C-c l" . flycheck-list-errors)
         ("C-c C-c a" . lsp-execute-code-action)
         ("C-c C-c r" . lsp-rename)
         ("C-c C-c q" . lsp-workspace-restart)
         ("C-c C-c Q" . lsp-workspace-shutdown)
         ("C-c C-c s" . lsp-rust-analyzer-status)
         ("C-c C-c e" . lsp-rust-analyzer-expand-macro)
         ("C-c C-c d" . dap-hydra)
         ("C-c C-c h" . lsp-ui-doc-glance))
  :custom
  (lsp-ui-peek-always-show t)
  (lsp-ui-sideline-show-hover nil) ; t to enable
  (lsp-ui-doc-enable t))
#+END_SRC
** Python
*** elpy
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t)

(add-hook 'python-mode-hook 'highlight-symbol-mode)
#+END_SRC
** Kotlin
#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode
  :ensure t)
#+END_SRC
** TODO YAML
The source code formatter =prettier=.
#+BEGIN_SRC emacs-lisp
  (use-package prettier
  :ensure t)
#+END_SRC
** nix-mode
#+BEGIN_SRC emacs-lisp
(use-package nix-mode
  :ensure t)
#+END_SRC
** Julia
#+BEGIN_SRC emacs-lisp
(use-package julia-mode
    :pin melpa-stable
    :ensure t)
#+END_SRC
** Elixir
See: [[https://elixir-lang.org/][elixir-lang.org]]
#+BEGIN_SRC emacs-lisp
(use-package elixir-mode
    :ensure t
    :bind
    (:map elixir-mode-map
          ("M-." . lsp-find-definition)
          ("M-," . xref-pop-marker-stack)
          ("C-M-," . (lambda ()
                       (interactive)
                       (kill-current-buffer)
                       (xref-pop-marker-stack)))
          ("<C-M-return>" . lsp-mode)
          ("<M-return>" . (lambda () (interactive)
                            (lsp-describe-thing-at-point)
                            (next-window-any-frame))))
    :config
    (add-hook 'elixir-mode-hook 'lsp-deferred)
    (add-hook 'lsp-mode-hook 'lsp-ui-mode)
    (add-to-list 'auto-mode-alist '("\\.ex\\'" . elixir-mode))
    (add-to-list 'auto-mode-alist '("\\.exs\\'" . elixir-mode))

    (defvar lsp-elixir--config-options (make-hash-table))

    ;; https://elixirforum.com/t/emacs-elixir-setup-configuration-wiki/19196?page=10
    (add-hook 'lsp-after-initialize-hook
              (lambda ()
                (lsp--set-configuration `(:elixirLS, lsp-elixir--config-options))))
)
#+END_SRC
** Haskell
See: [[https://blog.sumtypeofway.com/posts/emacs-config.html][My Emacs Configuration (Or, Emacs is Agar for Brain Worms) - 2020-09-14]]
*** company-ghci
#+BEGIN_SRC emacs-lisp
(use-package company-ghci
    :ensure t)
#+END_SRC
*** haskell-mode
Inspired by: [[https://blog.sumtypeofway.com/posts/emacs-config.html][blog.sumtypeofway.com/posts/emacs-config.html]].
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :config
      ;; haskell-mode doesn't know about newer GHC features.
      (let ((new-extensions
        '("QuantifiedConstraints" "DerivingVia" "BlockArguments"
          "DerivingStrategies" "StandaloneKindSignatures" )))
        (setq haskell-ghc-supported-extensions (append haskell-ghc-supported-extensions new-extensions)))

      ;; https://github.com/syl20bnr/spacemacs/issues/2489
      (setq haskell-process-use-presentation-mode t)

          ;; https://www.reddit.com/r/haskell/comments/e5gcq0/best_emacs_experience_for_haskell/
          ;;(setq haskell-hoogle-url
          ;;"https://hoogle.haskell.org/?hoogle=%s") (setq
          ;;haskell-hoogle-url "http://localhost:8080/?hoogle=%s")

      (setq haskell-mode-tag-find t)
    :bind (:map haskell-mode-map
             ("C-x c c" . haskell-cabal-visit-file)
             ("C-x c i" . haskell-navigate-imports)
             ("C-x c I" . haskell-navigate-imports-return)
             ("C-c C-z" . haskell-interactive-switch)
             ("C-c 1" . haskell-goto-first-error)
             ("C-c <" . haskell-goto-prev-error)
             ("C-c >" . haskell-goto-next-error)
             ("C-c <C-delete>" . haskell-process-restart)
             ("C-c o" . haskell-hoogle)
             ("C-c O" . haskell-hoogle-lookup-from-website)
             ("<C-S-return>" . haskell-process-load-file)
             ("<C-return>" . haskell-mode-show-type-at)
             ("<M-return>" . haskell-process-do-info)
             ("M-." . haskell-mode-jump-to-def) ;; haskell-mode-goto-loc
             ("M-," . xref-pop-marker-stack)
             ("M-F" . format-all-buffer)))
             
  (add-hook 'haskell-mode-hook #'highlight-symbol-mode)
  (add-to-list 'auto-mode-alist '("\\.hamlet\\'" . html-mode))
  (add-to-list 'auto-mode-alist '("\\.lucius\\'" . css-mode))
  (add-to-list 'auto-mode-alist '("\\.cassius\\'" . css-mode))
  (add-to-list 'auto-mode-alist '("\\.julius\\'" . js-mode))

  ;; Indent to 4 chars for Fourmolu (but better defined in
  ;;.dir-locals.el; hence commented out) (custom-set-variables
  ;;'(haskell-indentation-layout-offset 4)
  ;;'(haskell-indentation-starter-offset 4)
  ;;'(haskell-indentation-left-offset 4)
  ;;'(haskell-indentation-where-pre-offset 4)
  ;;'(haskell-indentation-where-post-offset 4))
#+END_SRC
See here for setup: [[https://stackoverflow.com/questions/56501112/haskell-emacs-haskell-mode-run-c-h-f-haskell-mode-for-instruction-how-to-setu][Haskell Emacs haskell-mode: Run 'C-h f haskell-mode' for instruction how to setup a Haskell interaction mode]].
*** eglot
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(use-package eglot
  :ensure t
  :config
  (add-hook 'haskell-mode-hook 'eglot-ensure)
  :config
  (setq-default eglot-workspace-configuration
                '((haskell
                   (plugin
                    (stan
                     (globalOn . :json-false))))))  ;; disable stan ;; TODO
  :custom
  (eglot-autoshutdown t)  ;; shutdown language server after closing last file
  (eglot-confirm-server-initiated-edits nil)  ;; allow edits without confirmation
  )
#+END_SRC
#+END_EXAMPLE
*** hindent
#+BEGIN_SRC emacs-lisp
  (use-package hindent
    :ensure t)
#+END_SRC
*** TODO format-all
See [[https://github.com/lassik/emacs-format-all-the-code][lassik/emacs-format-all-the-code]]

Annoying error; [[https://github.com/tweag/ormolu/issues/888][tweag/ormolu/issues/888]]
#+BEGIN_EXAMPLE
The --stdin-input-file option is necessary when using input from stdin and accounting for .cabal files
#+END_EXAMPLE

A format-all fixing issue is here: [[https://github.com/lassik/emacs-format-all-the-code/issues/216][lassik/emacs-format-all-the-code/issues/216]]

#+BEGIN_SRC emacs-lisp
  (use-package format-all
    :ensure t
    :bind
       ("M-F" . format-all-buffer)
       ("M-R" . format-all-region)
    ;; :config
    ;;   (define-format-all-formatter ormolu+
    ;;     (:executable "ormolu")
    ;;     (:install "stack install ormolu")
    ;;     (:languages "Haskell" "Literate Haskell")
    ;;     (:features)
    ;;     (:format (format-all--buffer-easy executable "--stdin-input-file" (buffer-file-name))))
    )

  ;;(add-hook 'format-all-mode-hook 'format-all-ensure-formatter)
  ;;(add-hook 'haskell-mode-hook 'format-all-mode)
  ;;(add-hook 'php-mode-hook 'format-all-mode)
#+END_SRC
*** direnv
See: [[https://github.com/wbolster/emacs-direnv#installation][wbolster/emacs-direnv#installation]]

#+BEGIN_SRC emacs-lisp
  (use-package direnv
    :ensure t)
#+END_SRC
** Purescript
Install =purescript-mode=. The irritating message can be fixed with a call to =turn-on-purescript-indentation= (see: [[https://github.com/purescript-emacs/psc-ide-emacs/issues/60][Issue with purescript-mode-hook]].
#+BEGIN_SRC emacs-lisp
  (use-package purescript-mode
      :ensure t
  ;;     :config (turn-on-purescript-indentation)
      :bind (:map purescript-mode-map
             ("C-c o" . purescript-pursuit)))
  ;; (add-hook 'purescript-mode-hook 'flycheck-mode)
  (add-hook 'purescript-mode-hook #'turn-on-purescript-indentation)
  (add-hook 'purescript-mode-hook #'purescript-decl-scan-mode)
#+END_SRC
** HLedger
#+BEGIN_SRC emacs-lisp
(use-package hledger-mode
    :ensure t)
(add-to-list 'auto-mode-alist '("\\.journal\\'" . hledger-mode))
#+END_SRC
** GraphQL
#+BEGIN_SRC emacs-lisp
(use-package graphql-mode
    :ensure t)
#+END_SRC
** Racket
#+BEGIN_SRC emacs-lisp
(use-package racket-mode
  :ensure t
  :bind (:map racket-mode-map
         ("C-c o" . racket-documentation-search)
         ("<M-return>" . racket-xp-describe)
         ("<C-return>" . racket-describe-search)
         ("<C-S-return>" . racket-run-module-at-point)))

(require 'racket-xp)
(add-hook 'racket-mode-hook #'racket-xp-mode)
(setq tab-always-indent 'complete)
#+END_SRC
** Rust
*** rust-mode
See [[https://github.com/rust-lang/rust-mode][rust-lang/rust-mode]] and e.g. [[https://robert.kra.hn/posts/rust-emacs-setup/][Configuring Emacs for Rust development - Robert Krahn]]
#+BEGIN_SRC emacs-lisp
(use-package rust-mode
    :pin melpa-stable
    :ensure t
    :bind (:map rust-mode-map
           ("M-F" . rust-format-buffer)
           ("M-." . lsp-find-definition)
           ("M-," . xref-pop-marker-stack)
           ("C-M-," . (lambda ()
                        (interactive)
                        (kill-current-buffer)
                        (xref-pop-marker-stack)))
           ("<C-return>" . lsp-execute-code-action)
           ("<M-return>" . (lambda () (interactive)
                             (lsp-describe-thing-at-point)
                             (next-window-any-frame)))))

(add-hook 'rust-mode-hook
          (lambda () (setq indent-tabs-mode nil)))
#+END_SRC
*** TODO rustic
Additional functionality in [[https://github.com/brotzeit/rustic][brotzeit/rustic]] ?
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
(use-package rustic
  :ensure t)
#+END_SRC
#+END_EXAMPLE
** TODO ChatGPT / CodeGPT
Beware: this requires access to OpenAI API, which is apparently not free.
*** ChatGPT generated code
Code generated in [[https://chat.openai.com/share/cdc1dd42-4465-4645-a103-bf85634efd79/continue][ChatGPT session]]:
#+BEGIN_EXAMPLE
(require 'url)
(require 'json)

(defvar chatgpt-prompt-buffer nil)

(defun start_chatgpt ()
  "Start a buffer for ChatGPT interaction."
  (interactive)
  (setq chatgpt-prompt-buffer (generate-new-buffer "*ChatGPT Prompt*"))
  (pop-to-buffer chatgpt-prompt-buffer)
  (erase-buffer) ; Clear the buffer
  (insert "Type your question or code snippet here.\n\n")
  (local-set-key (kbd "RET") 'send_chatgpt_request))

(defun send_chatgpt_request ()
  "Send the current prompt to ChatGPT."
  (interactive)
  (with-current-buffer chatgpt-prompt-buffer
    (let* ((prompt (buffer-string))
           (api-key (getenv "OPENAI_API_KEY")) ; Read API key from environment variable
           (url-request-method "POST")
           (url-request-extra-headers
            `(("Content-Type" . "application/json")
              ("Authorization" . ,(concat "Bearer " api-key))))
           (url-request-data
            (json-encode `(("messages" . (list (list "text" ,prompt)))
                           ("max_tokens" . 50)))))
      (url-retrieve
       "https://api.openai.com/v1/chat/completions"
       (lambda (status)
         (goto-char (point-min))
         (search-forward-regexp "\n\n")
         (let* ((response-json (buffer-substring (point) (point-max)))
                (response-data (json-read-from-string response-json))
                (response-text (cdr (assoc 'text (car response-data)))))
           (insert response-text "\n\n")))))))

(global-set-key (kbd "C-c A") 'start_chatgpt)
#+END_EXAMPLE

*** gptel
See: [[https://github.com/karthink/gptel][karthink/gptel]]
#+BEGIN_SRC emacs-lisp
(use-package gptel
 :pin melpa
 :ensure t)
#+END_SRC

Usage: Procure an OpenAI API key.
Optional: Set gptel-api-key to the key. Alternatively, you may choose a more secure method such as:
- Storing in ~/.authinfo. By default, api.openai.com is used as HOST and apikey as USER.
      =machine api.openai.com login apikey password TOKEN-

- Setting it to a function that returns the key.

*** codegpt
See: [[https://github.com/emacs-openai/codegpt][emacs-openai/codegpt]] [note: appears to work only for superficial queries]
#+BEGIN_EXAMPLE
(use-package codegpt
 :pin jcs-elpa
 :ensure t)

(add-to-list 'load-path "~/.emacs.d/lisp/")
(require 'codegpt)
#+END_EXAMPLE
** JSON
#+BEGIN_SRC emacs-lisp
(use-package json-mode
    :ensure t)
#+END_SRC
** HTML/CSS
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :diminish web-mode)
#+END_SRC
Package [[https://github.com/smihica/emmet-mode][emmet-mode]].
#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :diminish emmet-mode)

(add-hook 'web-mode-hook 'emmet-mode)  ;; Auto-start on web-mode.
(add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes.
(add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.
#+END_SRC
** PHP
*** php-mode
#+BEGIN_SRC emacs-lisp
(use-package php-mode
  :pin melpa-stable
  :ensure t
  :diminish php-mode)
#+END_SRC
*** jinja2-mode
(use-package jinja2-mode
  :pin melpa-stable
  :ensure t
  :diminish jinja2-mode)
*** Geben (Xdebug)
#+BEGIN_SRC emacs-lisp
(use-package geben
  :ensure t
  :diminish geben)
#+END_SRC
*** web-mode
#+BEGIN_SRC emacs-lisp
(require 'web-mode)
;; No web mode for PHP
;; (add-to-list 'auto-mode-alist '("\\.php" . web-mode))
(setq web-mode-engines-alist
  '(("php"    . "\\.phtml\\'")
    ("blade"  . "\\.blade\\."))
)
#+END_SRC
* Docker
Docker modes (file and compose).
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :pin melpa-stable
  :ensure t)

(use-package docker-compose-mode
  :pin melpa-stable
  :ensure t)
#+END_SRC
* Editing
** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind
    ("C-c c" . avy-goto-char))
#+END_SRC
** Words
*** Improved kill-word
Why on earth does a function called kill-word not .. kill a word. It instead deletes characters from your cursors position to the end of the word, lets make a quick fix and bind it properly.

[[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org]]
#+BEGIN_SRC emacs-lisp
(defun daedreth/kill-inner-word ()
  "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))
(global-set-key (kbd "C-c w k") 'daedreth/kill-inner-word)
#+END_SRC
*** Improved copy-word
And again, the same as above but we make sure to not delete the source word.

[[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org]]
#+BEGIN_SRC emacs-lisp
(defun daedreth/copy-whole-word ()
  (interactive)
  (save-excursion
    (forward-char 1)
    (backward-word)
    (kill-word 1)
    (yank)))
(global-set-key (kbd "C-c w c") 'daedreth/copy-whole-word)
#+END_SRC

** Navigation convenience shortcuts
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-M-S-up>") 'scroll-up-line)
(global-set-key (kbd "<C-M-S-down>") 'scroll-down-line)
(global-set-key (kbd "<C-prior>") 'previous-buffer)
(global-set-key (kbd "<C-next>") 'next-buffer)
#+END_SRC
** Navigation and S-exp
#+BEGIN_SRC emacs-lisp
;; Delete sexp.
(global-set-key (kbd "<C-S-delete>") 'kill-sexp)

;; Goto previous top level paren-block.
(global-set-key (kbd "M-p") 'outline-previous-visible-heading)
(global-set-key (kbd "M-n") 'outline-next-visible-heading)

;; C-arrow for word navigation.
(global-set-key (kbd "<C-left>") 'left-word)
(global-set-key (kbd "<C-right>") 'right-word)

;; Convenience key mappings for sexp navigation.
(global-set-key (kbd "C-x <left>") 'sp-backward-sexp)
(global-set-key (kbd "C-S-x <left>") 'sp-backward-up-sexp)
(global-set-key (kbd "C-x <right>") 'sp-forward-sexp)

;; Bury buffer (moves to end of buffer list).
(global-set-key (kbd "M-B") 'bury-buffer)
#+END_SRC
** Lines
*** Selecting
#+BEGIN_SRC emacs-lisp
(defun select-current-line ()
  "Select current line.
URL `http://ergoemacs.org/emacs/modernization_mark-word.html'
Version 2015-02-07
"
  (interactive)
  (end-of-line)
  (set-mark (line-beginning-position)))

;; Select current line.
(global-set-key (kbd "C-|") 'select-current-line)
#+END_SRC
*** Joining
#+BEGIN_SRC emacs-lisp
(defun join-next-line ()
  "Join next line."
  (interactive)
  (forward-line 1)
  (join-line))

;; Join line.
(global-set-key (kbd "C-S-J") 'join-next-line)
#+END_SRC
*** Deleting
#+BEGIN_SRC emacs-lisp
(defun delete-line-or-region (&optional n)
  "Delete current line, or region if active."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (if use-region
        (delete-region (region-beginning) (region-end))
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
        (delete-region (line-beginning-position) (line-end-position))
        (kill-whole-line)))))

;; Delete region.
(global-set-key (kbd "C-S-D") 'delete-line-or-region)
(global-set-key (kbd "<M-delete>") 'delete-line-or-region)
#+END_SRC
*** TODO Commenting
Instead of this check out [[https://github.com/yuutayamada/commenter][commenter]] package.
#+BEGIN_SRC emacs-lisp
(defun comment-line-or-region (&optional n)
  "Comment current line, or region if active."
  (interactive "*p")
  (let ((use-region (use-region-p)))
    (if use-region
        (comment-region (region-beginning) (region-end))
      (let ((pos (- (point) (line-beginning-position)))) ;Save column
        (comment-region (line-beginning-position) (line-end-position))))))

;; Comment current line or region.
(global-set-key (kbd "C-;") 'comment-line-or-region)
#+END_SRC
*** Move-dup
#+BEGIN_SRC emacs-lisp
  (use-package move-dup
    :ensure t)

  ;; Enable globally but disable for org-mode.
  (global-move-dup-mode)
  (add-hook 'org-mode-hook (lambda () (move-dup-mode 0)))
#+END_SRC
*** Truncating
See [[https://stackoverflow.com/questions/1775898/emacs-disable-line-truncation-in-minibuffer-only][Emacs: Disable line truncation in minibuffer only]]
#+BEGIN_SRC emacs-lisp
  ;; Disable line truncating by default (normally buffer local setting)
  ;; (set-default 'truncate-lines t)

  (setq resize-mini-windows t) ; grow and shrink as necessary
  (setq max-mini-window-height 4) ; grow up to max of 3 lines

  (add-hook 'minibuffer-setup-hook
        (lambda () (setq truncate-lines nil)))
#+END_SRC
*** TODO Numbering
Emacs29: Symbol's function definition is void: global-linum-mode 
#+BEGIN_SRC emacs-lisp
;; No line numbers by default.
;; (global-linum-mode 0)
;; (set-default 'global-linum-mode 0)

;; Line numbers for programming.
(add-hook 'prog-mode-hook (lambda () (display-line-numbers-mode 1)))
;(add-hook 'web-mode-hook (lambda () (linum-mode 1)))
#+END_SRC

*** Various
#+BEGIN_SRC emacs-lisp
  ;; Quick switch linum-mode.
  (global-set-key (kbd "C-S-n") 'display-line-numbers-mode)

  ;; Expand and replace region.
  (global-set-key (kbd "C-$") 'expand-delete-line)
#+END_SRC
** Change
*** Goto last change
#+BEGIN_SRC emacs-lisp
(use-package goto-last-change
  :ensure t)

(global-set-key (kbd "C-S-Q") 'goto-last-change)
#+END_SRC
*** TODO Undo tree
Frickin scattered undo files :-( CRAP!
#+BEGIN_SRC emacs-lisp
(setq undo-tree-auto-save-history nil)

;; https://emacs.stackexchange.com/questions/67929/how-can-i-prevent-undo-after-redo
(global-set-key (kbd "C-/") 'undo-only)
(global-set-key (kbd "C-S-/") 'undo-redo)
#+END_SRC

#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp
;; Adds a custom directory where some .el scripts are placed used in
;; this config file. Note that if you have .el scripts that exist on
;; Melpa, you don't need this directory. But I have an undo-tree
;; script (configured below) not on Melpa, so this is how you do it:
(add-to-list 'load-path (concat user-emacs-directory "macros-config"))

;; From http://www.emacswiki.org/emacs/UndoTree Script must exist in
;; the macros-config directory before proceeding (see above paragraph)
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :config (global-undo-tree-mode))

;; Replace regular undo and redo with respectively tree-undo and tree-redo.
(global-set-key (kbd "C-_") 'undo-tree-undo)
(global-set-key (kbd "C-/") 'undo-tree-undo)
(global-set-key (kbd "C-z") 'undo-tree-undo)

(global-set-key (kbd "M-_") 'undo-tree-redo)
(global-set-key (kbd "C-?") 'undo-tree-redo)
(global-set-key (kbd "C-S-Z") 'undo-tree-redo)

;; Undo tree visualize
(global-set-key (kbd "C-x u") 'undo-tree-visualize)

;; Lose the frickin scattered undo files.
(setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
#+END_SRC
#+END_EXAMPLE
** Parenthesis
*** Matching
Emacs lisp code from: [[https://www.emacswiki.org/emacs/NavigatingParentheses][Navigating Parentheses]].
#+BEGIN_SRC emacs-lisp
(defun goto-match-paren (arg)
  "Go to the matching parenthesis if on parenthesis. Else go to the
   opening parenthesis one level up."
  (interactive "p")
  (cond ((looking-at "\\s\(") (forward-list 1))
        (t
         (backward-char 1)
         (cond ((looking-at "\\s\)")
                (forward-char 1) (backward-list 1))
               (t
                (while (not (looking-at "\\s("))
                  (backward-char 1)
                  (cond ((looking-at "\\s\)")
                         (message "->> )")
                         (forward-char 1)
                         (backward-list 1)
                         (backward-char 1)))
                  ))))))

(global-set-key (kbd "C-S-P") 'goto-match-paren)
#+END_SRC
** Whitespaces
#+BEGIN_SRC emacs-lisp
;; Trim trailing whitespaces in current buffer.
(global-set-key (kbd "C-S-W") 'delete-trailing-whitespace)
#+END_SRC
** Search
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-S-F") 'find-dired)
(global-set-key (kbd "C-%") 'replace-string)

(use-package ag
  :ensure t
  :diminish ag-mode)
#+END_SRC
** Scroll
#+BEGIN_SRC emacs-lisp
  ;; Scroll without changing point.
  (global-set-key (kbd "s-<") 'scroll-right)
  (global-set-key (kbd "s->") 'scroll-left)

  (global-set-key (kbd "<C-up>") 'backward-paragraph)
  (global-set-key (kbd "<C-down>") 'forward-paragraph)
  ;; (global-set-key (kbd "<s-S-up>") 'scroll-up-line)
  ;; (global-set-key (kbd "<s-S-down>") 'scroll-down-line)
#+END_SRC
** Backup
#+BEGIN_SRC emacs-lisp
; Backup and auto-save.
(setq
  backup-by-copying t      ; don't clobber symlinks
  backup-directory-alist
   '(("." . "~/.saves"))    ; don't litter my fs tree
  delete-old-versions t
  kept-new-versions 6
  kept-old-versions 2
  version-control t)       ; use versioned backups

(setq backup-directory-alist
          `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t)))
#+END_SRC
** History
#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+END_SRC
* Shell
** Launch
#+BEGIN_SRC emacs-lisp
;; Shortcut to launch a shell
(global-set-key (kbd "C-x <return>") 'shell)

;; Open an eshell.
(global-set-key (kbd "C-x <C-return>") 'eshell)
#+END_SRC
* E-mail/usenet clients
** TODO gnus
:PROPERTIES:
:CUSTOM_ID: sec:gnus
:END:
See: [[https://protesilaos.com/dotemacs/][protesilaos.com/dotemacs/]] for an example configuration.
#+BEGIN_SRC emacs-lisp

#+END_SRC
** TODO Notmuch (emacs email client)
Check configuration with [[#sec:gnus]] above.
#+BEGIN_SRC emacs-lisp
(use-package notmuch
    :ensure t)

(setq notmuch-poll-script "notmuch-poll")

;; notmuch-hello-mode-map
;; notmuch-search-mode-map
;; notmuch-show-mode-map

;; The delete tag (toggles deleted tag); to actually delete use
;; e.g. the following command: notmuch search --output=files
;; tag:deleted | xargs -l rm (setq debug-on-error t) ;;TODO
(define-key notmuch-search-mode-map "d"
      (lambda ()
        "toggle deleted tag for message"
        (interactive)
        (if (member "deleted" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-deleted"))
          (notmuch-show-tag (list "+deleted")))))

(define-key notmuch-show-mode-map "d"
      (lambda ()
        "toggle deleted tag for message"
        (interactive)
        (if (member "deleted" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-deleted"))
          (notmuch-show-tag (list "+deleted")))))

;; The spam tag (toggles spam tag)
(define-key notmuch-search-mode-map "S"
      (lambda ()
        "toggle spam tag for message"
        (interactive)
        (if (member "spam" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-spam"))
          (notmuch-show-tag (list "+spam")))))

(define-key notmuch-show-mode-map "S"
      (lambda ()
        "toggle spam tag for message"
        (interactive)
        (if (member "spam" (notmuch-show-get-tags))
            (notmuch-show-tag (list "-spam"))
          (notmuch-show-tag (list "+spam")))))
#+END_SRC
* TODO Ignore-errors configuration
Is this ignore-errors construct necessary?
#+BEGIN_SRC emacs-lisp
;; These can produce errors when not in GUI mode (i.e. emacs --daemon).
(ignore-errors
  ;; Makes scrolling less jumpy.
  (setq scroll-margin 1
        scroll-conservatively 0
        scroll-up-aggressively 0.01
        scroll-down-aggressively 0.01)
  (setq-default scroll-up-aggressively 0.01
                scroll-down-aggressively 0.01)

  ;; scroll one line at a time (less "jumpy" than defaults)
  ;;  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
  (setq scroll-step 1) ;; keyboard scroll one line at a time

  ;; TODO Check and verify
  (setq scroll-step 1)
  (setq scroll-conservatively 10000)
  (setq auto-window-vscroll nil)
)
#+END_SRC
